---
title: 深信服面试手写代码：复杂链表的复制
date: 2022-10-12 11:51:50
tags: [技术, C++， 面试]
categories: 日常
index_img: /img/cpplogo.jpg
banner_img: /images/3lz25v.png
author: shuhui
---
深信服手撕代码，要求实现一个函数复制一个复杂链表，复杂链表中有一个随机指针可以指向任意节点或者nullptr；
leetcode以及剑指offer中有这一题，[leetcode](https://leetcode.cn/problems/copy-list-with-random-pointer/), [剑指offer](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/)
```cpp
struct ComplexListNode
{
    int val;
    ComplexListNode *next;
    ComplexListNode *random;
    ComplexListNode(int x) : val(x), next(nullptr), random(nullptr) {}
};
```

### 1. 构建复杂链表
首先需要知道如何构建复杂链表，当然在做题和面试时，只需要实现复制链表的函数即可。
这里的思路是分两次进行，首先遍历数组，取元素第一个值来构建单向链表, 同时构建一个数组tmp来存放每一个节点；然后再次遍历数组，取元素第二个值作为下标索引取出tmp中的节点，并将当前节点的随机指针指向该节点，当前节点不断后移；
```cpp
ComplexListNode *constructComplexList(vector<vector<int>> &nums)
{
    ComplexListNode *dummy = new ComplexListNode(0);
    ComplexListNode *cur = dummy;
    vector<ComplexListNode *> temp;
    for (vector<int> &n : nums)
    {
        cur->next = new ComplexListNode(n[0]);
        cur = cur->next;
        temp.push_back(cur);
    }
    cur = dummy->next;
    for (vector<int> &n : nums)
    {
        cur->random = temp[n[1]];
        cur = cur->next;
    }
    ComplexListNode *head = dummy->next;
    head->random = nullptr;
    delete dummy;
    return head;
}
```
或者使用unordered_map来存储已构建的节点也可以
```cpp
ComplexListNode *constructComplexList_2(vector<vector<int>> &nums)
{
    ComplexListNode *dummy = new ComplexListNode(0);
    ComplexListNode *cur = dummy;
    unordered_map<int, ComplexListNode *> mp;
    for (int i = 0; i < nums.size(); i++)
    {
        ComplexListNode *node = new ComplexListNode(nums[i][0]);
        mp[i] = node;
        cur->next = node;
        cur = cur->next;
    }
    cur = dummy->next;
    for (vector<int> &n : nums)
    {
        cur->random = mp[n[1]];
        cur = cur->next;
    }
    ComplexListNode *head = dummy->next;
    head->random = nullptr;
    delete dummy;
    return head;
}
```

### 2. 复制复杂链表
在这里复制复杂链表应该使用深拷贝的原理，即对于原链表的每一个节点都重新创建并开辟出一块新空间，而不是简单的指向原来的节点；
思路：
    
```cpp
ComplexListNode *copyComplexList(ComplexListNode *head)
{
    unordered_map<ComplexListNode *, ComplexListNode *> mp;
    ComplexListNode *cur = head;
    while (cur != nullptr)
    {
        mp[cur] = new ComplexListNode(cur->val);
        cur = cur->next;
    }
    cur = head;
    while (cur != nullptr)
    {
        mp[cur]->next = mp[cur->next];
        mp[cur]->random = mp[cur->random];
        cur = cur->next;
    }
    return head;
}
```