---
title: C++知识点总结p1
date: 2022-10-07 14:11:11
tags: [技术, C/C++]
categories: 技术
index_img: /img/cpplogo.jpg
banner_img: /images/2y8x99.png
---
### 1.数组
1. 如果在函数的内部定义了某种内置类型的数组，那么数组的默认初始化会令数组含有未定义的值；
2. 定义数组时，必须指定数组的类型，不允许使用auto关键字由初始值的列表推断类型；
3. 数组与vector一样，数组的元素应该为对象，不存在引用的数组；
4. 如果数组维度比提供的初始值数量大，则剩余的元素会被初始化为默认值，例如0值、空字符串等；
5. 不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值；某些编译器支持数组的赋值是由于**编译器扩展**；
### 2.C风格字符串
1. 使用比较运算符对C风格的字符串进行比较时，实际比较的是指针，即两个字符数组的地址，而非字符串本身，应该使用**strcmp函数**；
2. 在C++中字符串比较：
   1. 比较规则：
      1. 按顺序从前往后比较；
      2. 同序号的字符按ASCII码值比较
      3. 直到遇到对应字符不等或者字符串结束
   2. 采用比较运算符比较，返回值为bool类型
3. 在C风格字符串中比较：
   1. 使用strcmp函数进行比较：`int strcmp(const char* str1, const char* str2)`
   2. 如果两个字符串相同则返回0，str1>str2返回1，str1 < str2, 返回-1；

### 3.变量初始化
1. 定义于任何函数体之外的变量会被初始化为0；定义在函数体内部的内置类型变量将不被初始化，如果没有初始化，则其值为未定义；string类规定如果没有指定初始值则将会生成一个空串。
### 4.extern关键字
1. 变量声明规定了变量的类型和名字，使用extern关键字声明而不初始化则不是定义，不会申请内存空间， 而定义则会申请内存空间；
2. 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误；
3. 任何包含了显示初始化的声明即成为了定义，如```extern double pi = 3.1416;```， 这么做也就抵消了extern的作用；
4. 变量能且只能被定义一次，但是可以被声明多次；
5. 如果要在多个文件中使用同一个变量，就必须将声明和定义分离，此时，定义必须出现且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，且绝对不能重复定义。
### 4.变量初始化顺序
1. 基类的静态变量或成员变量；
2. 派生类的静态变量或全局变量
3. 基类的成员变量
4. 派生类的成员变量
- 注意：
1. 成员变量在使用初始化列表进行初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关；
2. 如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关；
3. 类中 const 成员常量必须在构造函数初始化列表中初始化；
4. 类中 static 成员变量必须在类外初始化；
### 5.const和指针
1. 指向常量的指针 `const int *p`: 指针指向的常量（对象）值不能改变；
2. 常量指针 `int *const p`: 指针指向的地址不能改变，即指针只能指向该变量，不能指向别处；
3. 指向常量的常量指针 `const int *const p`: 不论是指针所指向的对象的值，还是指针自己存储的地址值都不能被改变。
### 6.指针、常量和类型别名
```cpp
typedef char *pstring;
const pstring cstr = 0;     // cstr 是指向char的常量指针
const pstring *ps;          // ps是一个指针，它的对象是指向char的常量指针
```
由于pstring实际上是指向char的指针，因此，const pstring就是指向char的常量指针，而非指向常量字符的指针
**`const char *cstr = 0`, 这种理解是错误的，不能简单的将类型别名替换成它本来的样子。**

### 7.静态数据成员与非静态数据成员的区别
- 静态数据成员可以是不完全类型，可以说它所属的类类型；而非静态数据成员则受到限制，只能声明成它所属类的指针或引用
- 可以使用静态成员作为默认实参；非静态成员则不能，因为它的值本身属于对象的一部分；
- 静态成员处在所有对象之外
### 8.类的两项基本能力
- 数据抽象：定义数据成员和函数成员的能力；
- 封装：保护类的成员不被随意访问；设置为private
### 9.类可以将其他类或者函数设置为 友元，来赋予他们访问类的非公有成员的权限
### 10.构造函数应该使用构造函数初始值列表来初始化所有数据成员
### 11.关于递增和递减运算符
- 前置版本：首先将运算对象加1（减1），然后将改变后的对象作为求值结果；
- 后置版本：将运算对象加1（减1），求值结果是运算对象改变之前那个值的副本；
```cpp
int i = 0, j;
j = ++i;    // j = 1, i = 1; 前置版本得到递增之后的值
j = i++;    // j = 1, i = 2; 后置版本得到递增之前的值
```
由于后置版本需要将原始值存储下来，而前置版本则是直接返回递增后的值，因此建议优先考虑使用前置版本，从而避免后置版本的操作浪费。
### 12.static关键字
static有两种用法：面向过程中的static 和 面向对象中的static
1) 面向过程中的static
   静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区。自动变量一般会随着函数的退出而释放空间，静态数据（即使是函数内部的静态局部变量）也存放在全局数据区。全局数据区的数据并不会因为函数的退出而释放空间。
   - 静态全局变量：
      - 在全局数据区分配内存；
      - 未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非被显式初始化）；
      - 静态全局变量在声明它的整个文件都是可见的，而在该文件之外是不可见的；
      - 其它文件中可以定义相同名字的变量，不会发生冲突；
   - 静态局部变量：
     - 在全局数据区分配内存；
     - 在程序执行到该对象的声明处时被首次初始化，以后的函数调用不在进行初始化；
     - 一般在声明处初始化，如果没有显示初始化，会被程序自动初始化为0；
     - 始终驻留在全局数据区，直到程序运行结束，但其作用域是局部作用域，当定义其的函数或语句块结束时，作用域随之结束
   - 静态函数：
     - 在函数的返回类型前加上static关键字，即被定义为静态函数；
     - 函数只能在声明它的文件当中可见，不能被其他文件使用；
     - 其他文件中可以定义相同名字的函数，不会发生冲突；
2) 面向对象中的static
   - 静态数据成员：
     - 对于非静态数据成员，每个类对象都有自己的一份拷贝，而静态数据成员被当作是类的成员，无论类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问；即静态数据成员是该类的所有对象所共有的，对于类的多个对象来说，静态数据成员只分配一次内存，其值对所有对象都是一样的，且值可以更新；
     - 静态数据成员存储在全局数据区，定义时要分配空间，因此不能在类的声明中定义，而是在类中声明，但需要在类外进行定义；
     - 和普通数据成员一样，遵循public, private, protected访问规则；
     - 因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；
     - 静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：
        ```＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞```
     - 类的静态数据成员有两种访问形式：
        ```＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞```
      - 静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省存储空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了；
     - 同全局变量相比，使用静态数据成员有两个优势：
       1. 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；
       2. 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；
   - 静态成员函数
    与静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。静态成员函数与静态数据成员一样，都是类的内部实现，属于类定义的一部分。普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。如函数fn()实际上是this->fn()。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。
      - 出现在类体外的函数定义不能指定为static；
      - 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和静态成员函数；
      - 非静态成员可以任意地访问静态成员函数和静态数据成员；
      - 静态函数则不能访问非静态成员函数和非静态数据成员；
      - 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；
      - 调用静态成员函数可以使用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式：```＜类名＞::＜静态成员函数名＞（＜参数表＞）```调用类的静态成员函数.
### 13.函数指针
    ```cpp
    int fc(int);
    int (*pt)(int) = fc;
    // 3种调用方式
    pt(int);
    (*pt)(int);
    (pt)(int);
    ```
### 14.死锁、产生的必要条件、产生的原因、预防死锁
1. 死锁 
   两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。 
2. 产生死锁的必要条件 
   虽然进程在运行过程中，可能发生死锁，但死锁的发生也必须具备一定的条件，死锁的发生必须具备以下四个必要条件： 
   - 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放； 
   - 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放； 
   - 不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放； 
   - 环路等待条件：指在发生死锁时，必然存在一个[进程——资源]的环形链，即进程集合 {P0，P1，P2，···，Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，……，Pn 正在等待已被 P0 占用的资源。 
3. 产生死锁的原因 
   - 竞争资源 
   - 进程间推进顺序非法 
4. 预防死锁 
   - 有序资源分配法
    这种算法资源按某种规则系统中的所有资源统一编号（例如打印机为1、磁带机为2、磁盘为3、等等），申请时必须以上升的次序。系统要求申请进程：
      1. 对它所必须使用的而且属于同一类的所有资源，必须一次申请完；
      2. 在申请不同类资源时，必须按各类设备的编号依次申请。例如：进程PA，使用资源的顺序是R1，R2； 进程PB，使用资源的顺序是R2，R1；若采用动态分配有可能形成环路条件，造成死锁。

    采用有序资源分配法：R1的编号为1，R2的编号为2；
    - PA：申请次序应是：R1，R2
    - PB：申请次序应是：R1，R2
    这样就破坏了环路条件，避免了死锁的发生
   - 银行家算法
    银行家算法是避免死锁的一种重要方法。 
    操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，
    如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。
    当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。
    若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。
### 15.面向过程和面向对象
1. 面向过程：
   面向过程是一种以事件为中心的编程思想，编程的时候把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。
   优点：
        - 流程化使得编程任务明确，在开发之前基本考虑了实现方式和最终结果，具体步骤清楚，便于节点分析。
        - 效率高，面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序。

    缺点：
        - 需要深入的思考，耗费精力，代码重用性低，扩展能力差，后期维护难度比较大。
2. 面向对象：
   面向对象是一种以“对象”为中心的编程思想，把要解决的问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个对象在整个解决问题的步骤中的属性和行为。
   优点:
        1. 结构清晰，程序是模块化和结构化，更加符合人类的思维方式；
        2. 易扩展，代码重用率高，可继承，可覆盖，可以设计出低耦合的系统；
        3. 易维护，系统低耦合的特点有利于减少程序的后期维护工作量。
    缺点：
        1. 开销大，当要修改对象内部时，对象的属性不允许外部直接存取，所以要增加许多没有其他意义、只负责读或写的行为。这会为编程工作增加负担，增加运行开销，并且使程序显得臃肿。
        2. 性能低，由于面向更高的逻辑抽象层，使得面向对象在实现的时候，不得不做出性能上面的牺牲，计算时间和空间存储大小都开销很大。
### 16.进程通信的方式
管道、命名管道、信号、消息队列、共享内存、内存映射、信号量、Socket
1. 管道 管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，所有的 UNIX 系统都支持这种通信机制。管道本质其实是内核中维护的一块内存缓冲区，Linux 系统中通过 pipe() 函数创建管道，会生成两个文件描述符，分别对应管道的读端和写端。无名管道只能用于具有亲缘关系的进程间的通信。 
2. 命名管道 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO），也叫命名管道、FIFO文件。有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO 的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。 
3. 信号 信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。 
4. 消息队列 消息队列就是一个消息的链表，可以把消息看作一个记录，具有特定的格式以及特定的优先级，对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程则可以从消息队列中读走消息，消息队列是随内核持续的。 
5. 共享内存 共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会成为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。 
6. 内存映射 内存映射（Memory-mapped I/O）是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。 
7. 信号量 信号量主要用来解决进程和线程间并发执行时的同步问题，进程同步是并发进程为了完成共同任务采用某个条件来协调它们的活动。对信号量的操作分为 P 操作和 V 操作，P 操作是将信号量的值减 1，V 操作是将信号量的值加 1。当信号量的值小于等于 0 之后，再进行 P 操作时，当前进程或线程会被阻塞，直到另一个进程或线程执行了 V 操作将信号量的值增加到大于 0 之时。 
8. Socket 套接字（Socket），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。Socket 一般用于网络中不同主机上的进程之间的通信。
### 17.进程和线程的区别
1. 进程是操作系统进行资源调度和分配的基本单位,线程是操作系统可执行的最小调度和分配单位 
2. 一个线程属于一个进程,一个进程可以有多个线程 
3. 一个进程崩溃不影响其他进程,但是一个线程崩溃会让进程崩溃 
4. 进程在执行过程中有独立的存储单元,而线程之间共享进程的内存 
5. 进程之间切换系统开销大,而线程之间切换开销比进程小
---
1. 进程有独立的地址空间，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间； 
2. 进程和线程切换时，需要切换进程和线程的上下文，进程的上下文切换时间开销远远大于线程上下文切换时间，耗费资源较大，效率要差一些； 
3. 进程的并发性较低，线程的并发性较高； 
4. 每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制； 
5. 系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了 CPU 外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源； 
6. 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
---
协程：
是一种比线程更加轻量级的存在。一个线程也可以拥有多个协程。其执行过程更类似于子例程，或者说不带返回值的函数调用。
### 18.volatile关键字
volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：```volatile int vInt```; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。例如：
```cpp
volatile int i=10;
int a = i;
...
// 其他代码，并未明确告诉编译器，对 i 进行过操作
int b = i;
```
volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。而优化做法是，由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i是一个寄存器变量或者表示一个端口数据就容易出错，所以说 volatile 可以保证对特殊地址的稳定访问。\
### 19.内联函数
1. 内联函数的函数体内不能含有复杂的结构控制语句，如switch和while，否则编译器将该函数视同普通函数那样产生函数调用代码。
2. 递归函数不能被用来作为内联函数。
3. 内联函数一般适合于只有1-5行语句的小函数，对于一个含有很多语句的大函数，没必要使用内联函数来实现。
4. 内联函数的定义必须出现在内联函数第一次被调用之前。
5. 对内联函数不能进行异常接口声明，就是不能声明可能抛出的异常。
6. 在类中声明和定义的函数默认是隐式内联的，如果在类中声明，在类外定义，希望内联时，类外定义需要显式的使用inline。
### 20.[C++强制类型转换：static_cast、dynamic_cast、const_cast、reinterpret_cast](https://www.cnblogs.com/chenyangchun/p/6795923.html)
1. c语言强制类型转换主要用于基础的数据类型间的转换，语法为：
```cpp
(type-id)expression//转换格式1
type-id(expression)//转换格式2
```
2. c++除了能使用c语言的强制类型转换外，还新增了四种强制类型转换：static_cast、dynamic_cast、const_cast、reinterpret_cast，主要运用于继承关系类间的强制转化，语法为：
```cpp
static_cast<new_type>      (expression)
dynamic_cast<new_type>     (expression) 
const_cast<new_type>       (expression) 
reinterpret_cast<new_type> (expression)
```
备注：new_type为目标数据类型，expression为原始数据类型变量或者表达式。
- dynamic_cast将一个基类对象指针（或引用）cast到继承类指针，dynamic_cast会根据基类指针是否真正指向继承类指针来做相应处理， 即会作一定的判断。 对指针进行dynamic_cast，失败返回null，成功返回正常cast后的对象指针； 对引用进行dynamic_cast，失败抛出一个异常std::bad_cast，成功返回正常cast后的对象引用。 
- reinterpret_cast这个转换是最“不安全”的，两个没有任何关系的类指针之间转换都可以用这个转换实现。
- static_cast静态转换是最接近于C风格转换，很多时候都需要程序员自身去判断转换是否安全。
- const_cast这个转换好理解，可以将常量转成非常量。
### 21.运算符优先级
赋值运算符 < 逻辑运算符 < 关系运算符 < 算术运算符

### 22.可以用于字符串拷贝的函数memcpy(), strcpy(), strcmp(), strstr(), sprintf()
- memcpy()函数
```cpp
从数组a复制k个元素到数组b中：memcpy(b,a,sizeof(int/double)*k)
数组a全部复制到数组b中：memcpy(b,a,sizeof(a))
```
- strcpy()函数
```cpp
char *strcpy(char *destin, char *source);
功能：将source指向的字符串拷到destin，会覆盖之前的，source包含'\0'
```
- strcmp()函数
```cpp
int strcmp(char * str1,char * str2); 
功能: 比较两个字符串str1,str2
返回: str1<str2,返回负数;str1=str2,返回 0;str1>str2,返回正数,,按位比较
```
- strstr()函数
```cpp
char* strstr(char* str1,char* str2);
功能:找出str2字符串在str1字符串中第一次出现的位置(不包括str2的串结束符) 
返回: 返回该位置的指针,如找不到,返回空指针
char b[20]="abcdef";
printf("position:%s\n",strstr(b,"bc"));  //position:bcdef
```
- sprintf()函数
```cpp
把信息输出到字符串，保证字符串足够大 
char a[20]; 
memset(a,0,sizeof(a)); 
sprintf(a,"%d%d%d%d",4,5,6,7); 
for(int i=0;i<sizeof(a);i++){
  printf("%d ",a[i]);
}
//输出20位 52 53 54 55 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
puts(a)
// 输出4567
```
### 23.静态链接和动态链接
- 静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。
- 动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。

### 24.内存对齐
1. 为何需要内存对齐？
   现代计算机中内存空间都是按照字节(byte)进行划分的，所以从理论上讲对于任何类型的变量访问都可以从任意地址开始，但是在实际情况中，在访问特定类型变量的时候经常在特定的内存地址访问，所以这就需要把各种类型数据按照一定的规则在空间上排列，而不是按照顺序一个接一个的排放，这种就称为内存对齐，内存对齐是指首地址对齐，而不是说每个变量大小对齐。
2. 内存对齐的原则
   1. 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；
   2. 结构体每个成员相对于结构体首地址的偏移量都是当前成员大小的整数倍，如有需要编译器会在成员之间加上填充字节；
   3. 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。
说明：
   1. 基本类型是指前面提到的像char、short、int、float、double这样的内置数据类型；
   2. 对于复合数据类型，如结构体嵌套结构体，那么基本类型是指前面提到的像char、short、int、float、double这样的内置数据类型；
   3. 我认为计算结构体大小的时候，主要用到准则2和准则3，对于准则1是编译器自动完成的，不需要过多理会。
   4. C++中类的可以看做是特殊的结构体，所以类的sizeof的计算和结构体是一样的。
```cpp
    /* 如果以最长20字节为准，内部double占8字节，
    这段内存的地址0x00000020并不是double的整数倍，
    只有当最小为0x00000024时可以满足整除double（8Byte）同时又可以容纳int a[5]的大小，
    所以正确的结果应该是result=24 */  
    union example {    int a[5];    char b;    double c;   };   
    int result = sizeof(example);
    cout<<result<<endl;     // 24
    
    /* 如果我们不考虑字节对齐，那么内存地址0x0021不是double（8Byte）的整数倍，
    所以需要字节对齐，那么此时满足是double（8Byte）的整数倍的最小整数是0x0024，
    说明此时char b对齐int扩充了三个字节。所以最后的结果是result=32 */  
    struct example {    int a[5];    char b;    double c;   }test_struct; 
    int result = sizeof(test_struct); 
    cout<<result<<endl;     // 32
    
    /* 字节对齐除了内存起始地址要是数据类型的整数倍以外，还要满足一个条件，
    那就是占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍，
    所以20不是double（8Byte）的整数倍，我们还要扩充四个字节，最后的结果是result=24 */
    struct example {    char b;    double c;    int a;   }test_struct;   
    int result = sizeof(test_struct);   
    cout<<result<<endl;     // 24
```
### 25.深拷贝和浅拷贝
- 浅拷贝（默认拷贝函数）：将原对象或原数组的引用直接赋给新对象，新数组，新对象/新数组只是原对象的一个引用。
- 深拷贝：创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是引用。深拷贝会在堆内存中另外申请空间来储存数据，从而解决了指针悬挂问题。当数据成员中有指针时，必须要用深拷贝。
1. 在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。
2. 深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。
（1）如果拷贝的对象里的元素只有值，没有引用，那么深拷贝与浅拷贝是相同的。都会对原有对象复制一份，产生一个新对象，对新对象里的值进行修改不会影响原有对象，新对象与原对象完全分离开。
（2）如果拷贝的对象里的元素包含引用（像一个列表中储存着另一个列表，存的就是另一个列表的引用），那么浅拷贝和深拷贝是不同的。浅拷贝虽然将原有对象复制一份，但是依然保存的是引用，所以对新对象里的引用里的值进行修改，依然会改变原对象里的列表的值，新对象与原对象并没有完全分离开。深拷贝不同，它会将原对象里的引用也新创建一个，即新建一个列表，然后放的是新列表的引用，这样就可以将新对象和原对象完全分开。
(3)有指针时，必须用深拷贝当数据成员中含有指针时，必须用深拷贝当用浅拷贝时，新对象的指针与原对象的指针指向了堆上的同一块儿内存，新对象和原对象析构时，新对象先把其指向的动态分配的内存释放了一次，而后原对象析构时又将这块已经释放过的内存再释放一次。对同一块动态内存执行2次以上释放的结果是未定义的，所有会导致内存泄漏或程序崩溃。所以需要深拷贝来解决问题，当拷贝对象中有对其他资源（如堆、文件、系统等）的引用时（引用可以是指针或引用）时，对象开辟一块新的资源，而不再对拷贝对象中对其他资源的引用的指针或引用进行单纯的赋值。
### 26.类继承时，派生类对不同关键字修饰的基类方法的访问权限
类中的成员可以分为三种类型，分别为private成员、protected成员、public成员。类中可以直接访问自己类的public、protected、private成员，但类对象只能访问自己类的public成员。
1. public继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象可以访问基类的public成员，不可以访问基类的protected、private成员。
2. protected继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象不可以访问基类的public、protected、private成员。
3. private继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象不可以访问基类的public、protected、private成员。

### 26.C++ 类内可以定义引用数据成员吗？
c++类内可以定义引用成员变量，但要遵循以下三个规则：
1. 不能用默认构造函数初始化，必须提供构造函数来初始化引用成员变量。否则会造成引用未初始化错误。
2. 构造函数的形参也必须是引用类型。
3. 不能在构造函数里初始化，必须在初始化列表中进行初始化。

### 27.构造函数为什么不能被声明为虚函数？
1. 从存储空间角度：虚函数对应一个虚函数表,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，如何调用。（悖论）
2. 从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。
3. 从实现上看，虚函数表在构造函数调用后才建立，因而构造函数不可能成为虚函数。从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。
### 28. 简述一下什么是常函数(const函数)，有什么作用
类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加const，而对于改变数据成员的成员函数不能加 const。所以 const 关键字对成员函数的行为作了更明确的限定：有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；没有 const 修饰的成员函数，对数据成员则是可读可写的。除此之外，在类的成员函数后面加 const 还有什么好处呢？那就是常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数。正如非const类型的数据可以给const类型的变量赋值一样，反之则不成立。
### 29. [虚继承](url=https://zhuanlan.zhihu.com/p/35158136)
虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。虚继承可以解决多种继承前面提到的两个问题.
虚继承使派生类除了继承基类成员作为自己的成员之外，内部还会有一份内存来保存哪些是基类的成员。当final_derived继承derived1和derived2之后，编译器根据虚继承多出来的内存，查到derived1和derived2拥有共同的基类的成员，就不会从derived1和derived2中继承这些，而是直接从共同的基类中继承成员，也就是说，final_derived直接继承base的成员，然后再继承derived1和derived2各自新增的成员。

### 30. 简述一下虚函数和纯虚函数，以及实现原理
1. C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。如果调用非虚函数，则无论实际对象是什么类型，都执行基类类型所定义的函数。非虚函数总是在编译时根据调用该函数的对象，引用或指针的类型而确定。如果调用虚函数，则直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定或指针所指向的对象所属类型定义的版本。虚函数必须是基类的非静态成员函数。虚函数的作用是实现动态联编，也就是在程序的运行阶段动态地选择合适的成员函数，在定义了虚函数后，可以在基类的派生类中对虚函数重新定义，在派生类中重新定义的函数应与虚函数具有相同的形参个数和形参类型。以实现统一的接口，不同定义过程。如果在派生类中没有对虚函数重新定义，则它继承其基类的虚函数。
```cpp
class Person{
    public:
        //虚函数
        virtual void GetName(){
            cout<<"PersonName:xiaosi"<<endl;
        };
};
class Student:public Person{
    public:
        void GetName(){
            cout<<"StudentName:xiaosi"<<endl;
        };
};
int main(){
    //指针
    Person *person = new Student();
    //基类调用子类的函数
    person->GetName();//StudentName:xiaosi
}
```
虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。
2. 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0” `virtualvoid GetName() =0`。在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。为了解决上述问题，将函数定义为纯虚函数，则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。将函数定义为纯虚函数能够说明，该函数为后代类型提供了可以覆盖的接口，但是这个类中的函数绝不会调用。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。必须在继承类中重新声明函数（不要后面的＝0）否则该派生类也不能实例化，而且它们在抽象类中往往没有定义。定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。
```cpp
//抽象类
class Person{
   public:
      //纯虚函数
      virtual void GetName()=0;
};
class Student:public Person{
   public:
      Student(){
      };
      void GetName(){
            cout<<"StudentName:xiaosi"<<endl;
      };
};
int main(){
   Student student;
}
```
### 31. 说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？
1. 纯虚函数不可以实例化，但是可以用其派生类实例化，
2. 虚函数的原理采用 vtable。类中含有纯虚函数时，其vtable 不完全，有个空位。即“纯虚函数在类的vftable表中对应的表项被赋值为0。也就是指向一个不存在的函数。由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象。在它的派生类中，除非重写此函数，否则也不能生成对象。”所以纯虚函数不能实例化。
3. 纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。
4. 定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。

### 31.虚函数与纯虚函数的区别
1. 虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。
2. 虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。
3. 虚函数和纯虚函数都可以在子类中被重写，以多态的形式被调用。
4. 虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重写，目的是提供一个统一的接口。
5. 虚函数的定义形式：virtual{};纯虚函数的定义形式：virtual { } = 0;在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。

### 32.构造函数中能不能调用虚方法
不要在构造函数中调用虚方法，从语法上讲，调用完全没有问题，但是从效果上看，往往不能达到需要的目的。
派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。
同样，进入基类析构函数时，对象也是基类类型。
所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。

### 33.拷贝构造函数的参数是什么传递方式，为什么
**拷贝构造函数的参数必须使用引用传递**
如果拷贝构造函数中的参数不是一个引用，即形如`CClass(const CClass c_class)`，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。
需要澄清的是，传指针其实也是传值，如果上面的拷贝构造函数写成`CClass(const CClass* c_class)`，也是不行的。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。

### 34.抽象类
抽象类的定义如下：
1. 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”，有虚函数的类就叫做抽象类。
2. 抽象类有如下几个特点：
1）抽象类只能用作其他类的基类，不能建立抽象类对象。
2）抽象类不能用作参数类型、函数返回类型或显式转换的类型。
3）可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。

### 35.虚析构函数，什么作用
虚析构函数，是将基类的析构函数声明为virtual，举例如下：
```cpp
class TimeKeeper
{
public:    
    TimeKeeper() {}        
    virtual ~TimeKeeper() {}    
};
```
总的来说虚析构函数是为了避免内存泄露，而且是当子类中会有指针成员变量时才会使用得到的。也就说虚析构函数使得在删除指向子类对象的基类指针时可以调用子类的析构函数达到释放子类中堆内存的目的，而防止内存泄露的.
定义一个基类的指针p，在delete p时，如果基类的析构函数是虚函数，这时只会看p所赋值的对象，如果p赋值的对象是派生类的对象，就会调用派生类的析构函数（毫无疑问，在这之前也会先调用基类的构造函数，在调用派生类的构造函数，然后调用派生类的析构函数，基类的析构函数，所谓先构造的后释放）；如果p赋值的对象是基类的对象，就会调用基类的析构函数，这样就不会造成内存泄露。
如果基类的析构函数不是虚函数，在delete p时，调用析构函数时，只会看指针的数据类型，而不会去看赋值的对象，这样就会造成内存泄露。
总结一下虚析构函数的作用： 
1. 如果父类的析构函数不加virtual关键字 
当父类的析构函数不声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，只调动父类的析构函数，而不调动子类的析构函数。 
2. 如果父类的析构函数加virtual关键字 
当父类的析构函数声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，先调动子类的析构函数，再调动父类的析构函数。 
**父类的构造函数和析构函数是子类无法继承的，也就是说每一个类都有自己独有的构造函数和析构函数**

### 36.简述一下拷贝赋值和移动赋值？
拷贝赋值是通过拷贝构造函数来赋值，在创建对象时，使用同一类中之前创建的对象来初始化新创建的对象。
移动赋值是通过移动构造函数来赋值，二者的主要区别在于
1. 拷贝构造函数的形参是一个左值引用，而移动构造函数的形参是一个右值引用；
2. 拷贝构造函数完成的是整个对象或变量的拷贝，而移动构造函数是生成一个指针指向源对象或变量的地址，接管源对象的内存，相对于大量数据的拷贝节省时间和内存空间。

### 37. 仿函数了解吗？有什么作用
仿函数（functor）又称为函数对象（function object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载operator()运算符(函数调用运算符，即()括号运算符)，举个例子：
```cpp
class Func{
public:
    void operator() (const string& str) const {
        cout<<str<<endl;
    }
};

Func myFunc;
myFunc("helloworld!");

>>>helloworld!
```

### 38.C++ 中哪些函数不能被声明为虚函数？
常见的不不能声明为虚函数的有：普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数。
1. 为什么C++不支持普通函数为虚函数？
   普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。
2. 为什么C++不支持构造函数为虚函数？
   这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）
   构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数
3. 为什么C++不支持内联成员函数为虚函数？
   其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数）
   内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数
4. 为什么C++不支持静态成员函数为虚函数？
   这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。
   静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别
5. 为什么C++不支持友元函数为虚函数？
   因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。

### 39.  C++ 中类模板和模板类的区别
1. 类模板是模板的定义，不是一个实实在在的类，定义中用到通用类型参数
2. 模板类是实实在在的类定义，是**类模板的实例化**。在类定义中参数被实际类型所代替。
所谓类模板，实际上是建立一个通用类，其数据成员、成员函数的返回值类型和形参类型不具体指定，用一个虚拟的类型来代表。使用类模板定义对象时，系统会用实参的类型来取代类模板中虚拟类型从而实现了不同类的功能。
```cpp
template <typename 类型参数>
class 类名{
       类成员声明 
};

或者

template <class 类型参数>
class 类名{
       类成员声明 
};
```

### 40. [虚函数表里存放的内容是什么时候写进去的？](url=https://blog.csdn.net/ThinPikachu/article/details/104481011)
1. 虚函数表是一个存储虚函数地址的数组,以NULL结尾。虚表（vftable）在编译阶段生成，对象内存空间开辟以后，写入对象中的 vfptr，然后调用构造函数。即：虚表在构造函数之前写入
2. 除了在构造函数之前写入之外，我们还需要考虑到虚表的二次写入机制，通过此机制让每个对象的虚表指针都能准确的指向到自己类的虚表，为实现动多态提供支持。所谓的虚表的二次写入指的是在继承关系中，派生类对象要调用两次构造函数，一次是基类的，另外一次是自己的，因此虚表要写入两次。
   - 首先是在编译间段生成基类和派生类的虚函数表，注意，其实这里的派生类虚表不是真正的派生类的虚表，最终的派生类的虚表是派生类虚表和基类虚表合并以后的产物。
   - 接着是派生类对象首先给从基类中继承下来的成员开辟内存，接着在调用基类的构造函数之前指向基类的虚表，
   - 接下来调用基类的构造函数，将基类的成员全部赋值为0，即将基类的vfptr指向NULL
   - 接着是派生类对象为自己的成员开辟内存
   - 接着在调用派生类的构造函数之前将vfptr指向派生类的虚表，在这之前，要进行虚表合并，生成派生类最终的虚函数表
   - 接着在调用派生类的构造函数之前，将派生类的虚函数指针指向派生类的最终虚函数表
   - 最后进行虚函数指针的合并，由外向内合并

### 41.迭代器用过吗？什么时候会失效？
常用容器迭代器失效情形如下。
1. 对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。
2. 对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。
3. 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。

### 42. 说一下STL中迭代器的作用，有指针为何还要迭代器？
Iterator（迭代器）模式又称游标（Cursor）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。 由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展Iterator。
1. 迭代器的作用
（1）用于指向顺序容器和关联容器中的元素
（2）通过迭代器可以读取它指向的元素
（3）通过非const迭代器还可以修改其指向的元素
2. 迭代器和指针的区别
   1. 迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，重载了指针的一些操作符，-->、++、--等。迭代器封装了指针，是一个”可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象，本质是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。
   2. 迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。
3. 迭代器产生的原因
   Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。

### 43.说说 STL 中 resize 和 reserve 的区别
1. 首先必须弄清楚两个概念：
（1）capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素的个数。还不能通过下标等访问，因为此时容器中还没有创建任何对象。
（2）size：指的是此时容器中实际的元素个数。可以通过下标访问0-(size-1)范围内的对象。
2. resize和reserve区别主要有以下几点：
（1）resize既分配了空间，也创建了对象；reserve表示容器预留空间，但并不是真正的创建对象，需要通过insert（）或push_back（）等创建对象。
（2）resize既修改capacity大小，也修改size大小；reserve只修改capacity大小，不修改size大小。
（3）两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值（默认为0）；reserve只带一个参数，表示容器预留的大小。
3. 问题延伸：
    - resize 和 reserve 既有差别，也有共同点。两个接口的共同点是它们都保证了vector的空间大小(capacity)最少达到它的参数所指定的大小。下面就他们的细节进行分析。
    - 为实现resize的语义，resize接口做了两个保证：
        （1）保证区间[0, new_size)范围内数据有效，如果下标index在此区间内，vector[indext]是合法的；

        （2）保证区间[0, new_size)范围以外数据无效，如果下标index在区间外，vector[indext]是非法的。
    - reserve只是保证vector的空间大小(capacity)最少达到它的参数所指定的大小n。在区间[0, n)范围内，如果下标是index，vector[index]这种访问有可能是合法的，也有可能是非法的，视具体情况而定。
    以下是两个接口的源代码：        
```cpp
void resize(size_type new_size)
{
    resize(new_size, T());
}
void resize(size_type new_size, const T &x)
{
    if (new_size < size())
        erase(begin() + new_size, end()); // erase区间范围以外的数据，确保区间以外的数据无效
    else
        insert(end(), new_size - size(), x); // 填补区间范围内空缺的数据，确保区间内的数据有效
}
#include <iostream>
#include <vector>
using namespace std;
int main()
{
    vector<int> a;
    cout << "initial capacity:" << a.capacity() << endl;
    cout << "initial size:" << a.size() << endl; /*resize改变capacity和size*/
    a.resize(20);
    cout << "resize capacity:" << a.capacity() << endl;
    cout << "resize size:" << a.size() << endl;
    vector<int> b; /*reserve改变capacity,不改变resize*/
    b.reserve(100);
    cout << "reserve capacity:" << b.capacity() << endl;
    cout << "reserve size:" << b.size() << endl;
    return 0;
}
/*      
运行结果：   
initial capacity:0  
initial size:0  
resize capacity:20  
resize size:20  
reserve capacity:100  
reserve size:0 
*/ 
```
注意：如果n大于当前的vector的容量(是容量，并非vector的size)，将会引起自动内存分配。所以现有的pointer,references,iterators将会失效。而内存的重新配置会很耗时间。

### 44.STL 容器动态链接可能产生的问题？
1. 可能产生的问题
    容器是一种动态分配内存空间的一个变量集合类型变量。在一般的程序函数里，局部容器，参数传递容器，参数传递容器的引用，参数传递容器指针都是可以正常运行的，而在动态链接库函数内部使用容器也是没有问题的，但是给动态库函数传递容器的对象本身，则会出现内存堆栈破坏的问题。
2. 产生问题的原因 
   容器和动态链接库相互支持不够好，动态链接库函数中使用容器时，参数中只能传递容器的引用，并且要保证容器的大小不能超出初始大小，否则导致容器自动重新分配，就会出现内存堆栈破坏问题。
### 45. 说说 map 和 unordered_map 的区别？底层实现
map和unordered_map的区别在于他们的实现基理不同。
1. map实现机理
    map内部实现了一个红黑树（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。
2. unordered_map实现机理
   unordered_map内部实现了一个哈希表（也叫散列表），通过把关键码值映射到Hash表中一个位置来访问记录，查找时间复杂度可达O（1），其中在海量数据处理中有着广泛应用。因此，元素的排列顺序是无序的。

### 46.说说 vector 和 list 的区别，分别适用于什么场景？
vector和list区别在于底层实现机理不同，因而特性和适用场景也有所不同。
1. vector：一维数组
   - 特点：元素在内存连续存放，动态数组，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后内存也不会释放。
   - 优点：和数组类似开辟一段连续的空间，并且支持随机访问，所以它的查找效率高其时间复杂度O(1)。
   - 缺点：由于开辟一段连续的空间，所以插入删除会需要对数据进行移动比较麻烦，时间复杂度O（n），另外当空间不足时还需要进行扩容。
2. list：双向链表
   - 特点：元素在堆中存放，每个元素都是存放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问。
   - 优点：底层实现是循环双链表，当对大量数据进行插入删除时，其时间复杂度O(1)。
   - 缺点：底层没有连续的空间，只能通过指针来访问，所以查找数据需要遍历其时间复杂度O（n），没有提供[]操作符的重载。
应用场景
   - vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。
   - list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。
### 47. map 和 set 有什么区别，分别又是怎么实现的？
1. set是一种关联式容器，其特性如下：
（1）set以RBTree作为底层容器
（2）所得元素的只有key没有value，value就是key
（3）不允许出现键值重复
（4）所有的元素都会被自动排序
（5）不能通过迭代器来改变set的值，因为set的值就是键，set的迭代器是const的
2. map和set一样是关联式容器，其特性如下：
（1）map以RBTree作为底层容器
（2）所有元素都是键+值存在
（3）不允许键重复
（4）所有元素是通过键进行自动排序的
（5）map的键是不能修改的，但是其键对应的值是可以修改的
综上所述，map和set底层实现都是红黑树；map和set的区别在于map的值不作为键，键和值是分开的。
### 48. push_back 和 emplace_back 的区别
如果要将一个临时变量push到容器的末尾，push_back()需要先构造临时对象，再将这个对象拷贝到容器的末尾，而emplace_back()则直接在容器的末尾构造对象，这样就省去了拷贝的过程。

### 49. vector扩容
Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，再插入新增的元素。
vector的扩容一般有两种方式：半步扩容法（即扩容1.5倍）和2倍扩容法（即扩容2倍）
两者之间的区别重点表现在空间和时间两方面。
2倍扩容时间快，但是不能使用之前的空间，造成空间上的浪费。而1.5倍扩容刚好相反，节省了空间，却因此消耗了更多的时间。
| 编译器 | 扩容倍数 |
| :----: | :------: |
|  GCC   |    2     |
|  MSVC  |   1.5    |
| CLANG  |   1.5    |

### 50.  C++11 的新特性有哪些
C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点：
1. 语法的改进
（1）统一的初始化方法
（2）成员变量默认初始化
（3）auto关键字    用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）
（4）decltype    求表达式的类型
（5）智能指针 shared_ptr
（6）空指针 nullptr（原来NULL）
（7）基于范围的for循环
（8）右值引用和move语义    让程序员有意识减少进行深拷贝操作
2. 标准库扩充（往STL里新加进一些模板类，比较好用）
（9）无序容器（哈希表）    用法和功能同map一模一样，区别在于哈希表的效率更高
（10）正则表达式    可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串
（11）Lambda表达式
---
**decltype    求表达式的类型**
decltype 是 C++11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。
(1)为什么要有decltype
    因为 auto 并不适用于所有的自动类型推导场景，在某些特殊情况下 auto 用起来非常不方便，甚至压根无法使用，所以 decltype 关键字也被引入到 C++11 中。
    auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：
    `auto varname = value; decltype(exp) varname = value;`
    其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。
    auto 根据"="右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟"="右边的 value 没有关系。
    另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。decltype 可以写成下面的形式：
    `decltype(exp) varname;`
(2)代码示例
```cpp
// decltype 用法举例 
int a = 0; decltype(a) b = 1;  //b 被推导成了int 
decltype(10.8) x = 5.5;  //x 被推导成了 double 
decltype(x + 100) y;  //y 被推导成了 double
 ```

**智能指针 shared_ptr**
    和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。
```cpp
#include <iostream>
#include <memory>
using namespace std;
int main()
{ //构建 2 个智能指针
    std::shared_ptr<int> p1(new int(10));
    std::shared_ptr<int> p2(p1);
    //输出 p2 指向的数据
    cout << *p2 << endl;
    p1.reset(); //引用计数减 1,p1为空指针
    if (p1)
    {
        cout << "p1 不为空" << endl;
    }
    else
    {
        cout << "p1 为空" << endl;
    }
    //以上操作，并不会影响 p2
    cout << *p2 << endl;
    //判断当前和 p2 同指向的智能指针有多少个
    cout << p2.use_count() << endl;
    return 0;
}
/*      程序运行结果：          10  p1 为空  10  1  */
```

**正则表达式**
可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串。常用符号的意义如下：
|符号|意义|
|:--:|:--:|
|^|匹配行的开头|
|$|匹配行的结尾|
|.|匹配任意单个字符|
|[…]	|匹配[]中的任意一个字符|
|(…)	|设定分组|
|\	|转义字符|
|\d	|匹配数字[0-9]|
|\D	|\d 取反|
|\w	|匹配字母[a-z]，数字，下划线|
|\W	|\w 取反|
|\s	|匹配空格|
|\S	|\s 取反|
|+	|前面的元素重复1次或多次|
|*	|前面的元素重复任意次|
|?	|前面的元素重复0次或1次|
|{n}	|前面的元素重复n次|
|{n,}	|前面的元素重复至少n次|
|{n,m}	|前面的元素重复至少n次，至多m次|
||	|逻辑或|

**Lambda匿名函数**
所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。
（1）定义
    lambda 匿名函数很简单，可以套用如下的语法格式：
      `[外部变量访问方式说明符] (参数) mutable noexcept/throw() -> 返回值类型         {           函数体;         };`
其中各部分的含义分别为：
a. [外部变量方位方式说明符]     [ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。
    所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。
b. (参数)     和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；
c. mutable     此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。
    注意:对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；
d. noexcept/throw()     可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。
e. -> 返回值类型     指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略"-> 返回值类型"。
f. 函数体     和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。
（2）程序实例
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
    int num[4] = {4, 2, 3, 1};
    //对 a 数组中的元素进行排序
    sort(num, num+4, [=](int x, int y) -> bool{ return x < y; } );
    for(int n : num){
        cout << n << " ";
    }
    return 0;
}

/*    程序运行结果：
          1 2 3 4
*/  
```
### 51. C++ 中智能指针和指针的区别是什么？
1. 智能指针
    如果在程序中使用new从堆（自由存储区）分配内存，等到不需要时，应使用delete将其释放。C++引用了智能指针auto_ptr，以帮助自动完成这个过程。随后的编程体验（尤其是使用STL）表明，需要有更精致的机制。基于程序员的编程体验和BOOST库提供的解决方案，C++11摒弃了auto_ptr，并新增了三种智能指针：unique_ptr、shared_ptr和weak_ptr。所有新增的智能指针都能与STL容器和移动语义协同工作。
2. 指针
    C 语言规定所有变量在使用前必须先定义，指定其类型，并按此分配内存单元。指针变量不同于整型变量和其他类型的变量，它是专门用来存放地址的，所以必须将它定义为“指针类型”。
3. 智能指针和普通指针的区别
    智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。

### 52. C++中的智能指针有哪些？分别解决的问题以及区别？
C++中的智能指针有4种，分别为：shared_ptr、unique_ptr、weak_ptr、auto_ptr，其中auto_ptr被C++11弃用。
1. 使用智能指针的原因
    申请的空间（即new出来的空间），在使用结束时，需要delete掉，否则会形成内存碎片。在程序运行期间，new出来的对象，在析构函数中delete掉，但是这种方法不能解决所有问题，因为有时候new发生在某个全局函数里面，该方法会给程序员造成精神负担。此时，智能指针就派上了用场。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以，智能指针的作用原理就是在函数结束时自动释放内存空间，避免了手动释放内存空间。
2. 四种指针分别解决的问题以及各自特性如下：
   1. auto_ptr（C++98的方案，C++11已经弃用）
    采用所有权模式。
   ```cpp
   auto_ptr<string> p1(new string("I reigned loney as a cloud."));
   auto_ptr<string> p2;
   p2=p1; //auto_ptr不会报错
   ```
   此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题。
   2. unique_ptr（替换auto_ptr）
      unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露，例如，以new创建对象后因为发生异常而忘记调用delete时的情形特别有用。
      采用所有权模式，和上面例子一样。

   ```cpp
   auto_ptr<string> p3(new string("I reigned loney as a cloud."));
   auto_ptr<string> p4;
   p4=p3; //此时不会报错
   ```
   编译器认为P4=P3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。 另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：

   ```cpp
   unique_ptr<string> pu1(new string ("hello world"));
   unique_ptr<string> pu2;
   pu2 = pu1;                                      // #1 not allowed
   unique_ptr<string> pu3;
   pu3 = unique_ptr<string>(new string ("You"));   // #2 allowed
   ```
   其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。

   注意：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：

   ```cpp
   unique_ptr<string> ps1, ps2;
   ps1 = demo("hello");
   ps2 = move(ps1);
   ps1 = demo("alexia");
   cout << *ps2 << *ps1 << endl;
   ```

   3. shared_ptr（非常好使）
    shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。
    shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。
      - 成员函数：
         - use_count    返回引用计数的个数
         - unique    返回是否是独占所有权( use_count 为 1)
         - swap    交换两个 shared_ptr 对象(即交换所拥有的对象)
         - reset    放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少
         - get    返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的
   4. weak_ptr
    weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr。weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。

   ```cpp
   class B;
   class A
   {
   public:
      shared_ptr<B> pb_;
      ~A()
   {
      cout<<"A delete\n";
   }
   };
   class B
   {
   public:
      shared_ptr<A> pa_;
      ~B()
   {
      cout<<"B delete\n";
   }
   };
   void fun()
   {
      shared_ptr<B> pb(new B());
      shared_ptr<A> pa(new A());
      pb->pa_ = pa;
      pa->pb_ = pb;
      cout<<pb.use_count()<<endl;
      cout<<pa.use_count()<<endl;
   }
   int main()
   {
      fun();
      return 0;
   }
   ```
   可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。

   注意：我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa->pb->print(); 英文pb是一个weak_ptr，应该先把它转化为shared_ptr，如：shared_ptr p = pa->pb_.lock(); p->print(); 

### 53. 简述 C++ 中智能指针的特点
C++中的智能指针有4种，分别为：shared_ptr、unique_ptr、weak_ptr、auto_ptr，其中auto_ptr被C++11弃用。    
1. 为什么要使用智能指针：智能指针的作用是管理一个指针，因为存在申请的空间在函数结束时忘记释放，造成内存泄漏的情况。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，自动释放资源。
2. 四种指针各自特性
   （1）auto_ptr
      auto指针存在的问题是，两个智能指针同时指向一块内存，就会两次释放同一块资源，自然报错。
   （2）unique_ptr
      unique指针规定一个智能指针独占一块内存资源。当两个智能指针同时指向一块内存，编译报错。
      实现原理：将拷贝构造函数和赋值拷贝构造函数申明为private或delete。不允许拷贝构造函数和赋值操作符，但是支持移动构造函数，通过std:move把一个对象指针变成右值之后可以移动给另一个unique_ptr
   （3）shared_ptr
      共享指针可以实现多个智能指针指向相同对象，该对象和其相关资源会在引用为0时被销毁释放。
      实现原理：有一个引用计数的指针类型变量，专门用于引用计数，使用拷贝构造函数和赋值拷贝构造函数时，引用计数加1，当引用计数为0时，释放资源。
注意：weak_ptr、shared_ptr存在一个问题，当两个shared_ptr指针相互引用时，那么这两个指针的引用计数不会下降为0，资源得不到释放。因此引入weak_ptr，weak_ptr是弱引用，weak_ptr的构造和析构不会引起引用计数的增加或减少。

### 54. weak_ptr 能不能知道对象计数为 0，为什么？
不能。
weak_ptr是一种不控制对象生命周期的智能指针，它指向一个shared_ptr管理的对象。进行该对象管理的是那个引用的shared_ptr。weak_ptr只是提供了对管理 对象的一个访问手段。weak_ptr设计的目的只是为了配合shared_ptr而引入的一种智能指针，配合shared_ptr工作，它只可以从一个shared_ptr或者另一个weak_ptr对象构造，它的构造和析构不会引起计数的增加或减少。

### 55. weak_ptr 如何解决 shared_ptr 的循环引用问题？
为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问。

### 56. share_ptr 怎么知道跟它共享对象的指针释放了
多个shared_ptr对象可以同时托管一个指针，系统会维护一个托管计数。当无shared_ptr托管该指针时，delete该指针。

### 57. 智能指针有没有内存泄露的情况
智能指针有内存泄露的情况发生。
1. 智能指针发生内存泄露的情况
   当两个对象同时使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄露。
2. 智能指针的内存泄漏如何解决？ 
   为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问。

### 58. 简述一下 C++11 中四种类型转换
C++中四种类型转换分别为const_cast、static_cast、dynamic_cast、reinterpret_cast，四种转换功能分别如下：
1. const_cast
        将const变量转为非const
2. static_cast
    最常用，可以用于各种隐式转换，比如非const转const，static_cast可以用于类向上转换，但向下转换能成功但是不安全。
3. dynamic_cast
   只能用于含有虚函数的类转换，用于类向上和向下转换
      - 向上转换：指子类向基类转换。    
      - 向下转换：指基类向子类转换。

   这两种转换，子类包含父类，当父类转换成子类时可能出现非法内存访问的问题。
   dynamic_cast通过判断变量运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。dynamic_cast可以做类之间上下转换，转换的时候会进行类型检查，类型相等成功转换，类型不等转换失败。运用RTTI技术，RTTI是”Runtime Type Information”的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法。在c++层面主要体现在dynamic_cast和typeid，vs中虚函数表的-1位置存放了指向type_info的指针，对于存在虚函数的类型，dynamic_cast和typeid都会去查询type_info。
1. reinterpret_cast
            reinterpret_cast可以做任何类型的转换，不过不对转换结果保证，容易出问题。
注意：为什么不用C的强制转换：C的强制转换表面上看起来功能强大什么都能转，但是转换不够明确，不能进行错误检查，容易出错。

### 59. auto和 const 的结合使用
1. auto 与 const 结合的用法
        a. 当类型不为引用时，auto 的推导结果将不保留表达式的 const 属性；
        b. 当类型为引用时，auto 的推导结果将保留表达式的 const 属性。
2. 程序实例如下
```cpp
int  x = 0;
const  auto n = x;  //n 为 const int ，auto 被推导为 int
auto f = n;      //f 为 const int，auto 被推导为 int（const 属性被抛弃）
const auto &r1 = x;  //r1 为 const int& 类型，auto 被推导为 int
auto &r2 = r1;  //r1 为 const int& 类型，auto 被推导为 const int 类型
/*
a. 第 2 行代码中，n 为 const int，auto 被推导为 int。
b. 第 3 行代码中，n 为 const int 类型，但是 auto 却被推导为 int 类型，这说明当=右边的表达式带有 const 属性时，auto 不会    使用 const 属性，而是直接推导出 non-const 类型。
c. 第 4 行代码中，auto 被推导为 int 类型，这个很容易理解，不再赘述。
d. 第 5 行代码中，r1 是 const int & 类型，auto 也被推导为 const int 类型，这说明当 const 和引用结合时，auto 的推导将保留    表达式的 const 类型。
*/
```

### 60. 可变参数模板
1. C++11的新特性可变参数模板能够让您创建可以接受可变参数的函数模板和类模板，相比C++98/03，类模版和函数模版中只能含固定数量的模版参数，可变模版参数无疑是一个巨大的改进。然而由于可变模版参数比较抽象，使用起来需要一定的技巧，所以这块还是比较晦涩的。现阶段呢，我们掌握一些基础的可变参数模板特性就够我们用了。
```cpp
// Args是一个模板参数包，args是一个函数形参参数包
// 声明一个参数包Args...args，这个参数包中可以包含0到任意个模板参数。
template <class ...Args>
void ShowList(Args... args)
{}
```
上面的参数args前面有省略号，所以它就是一个可变模版参数，我们把带省略号的参数称为“参数包”，它里面包含了0到N（N>=0）个模版参数。我们无法直接获取参数包args中的每个参数的，只能通过展开参数包的方式来获取参数包中的每个参数，这是使用可变模版参数的一个主要特点，也是最大的难点，即如何展开可变模版参数。由于语法不支持使用args[i]这样方式获取可变参数，所以我们的用一些奇招来一一获取参数包的值。

2. 递归函数方式展开参数包
```cpp
// 递归终止函数，当只有一个参数时特殊处理
template<class T, class ...Args>
void ShowList(T value)
{
	cout << typeid(value).name() << ": " << value << endl;
}
template<class T, class ...Args>
void ShowList(T value, Args... args)
{
	// cout << sizoef(args...) << endl;无法计算可变参数的大小
	cout << typeid(value).name() << ": " << value << endl;
	ShowList(args...); // 他会自动解析出一个类型给 value 
}
int main()
{
	ShowList(1);
	ShowList(1, 'A');
	ShowList(1, 'A', std::string("sort"));
	return 0;
}
```
3. 逗号表达式展开参数包
这种展开参数包的方式，不需要通过递归终止函数，是直接在expand函数体中展开的, printarg不是一个递归终止函数，只是一个处理参数包中每一个参数的函数。
这种就地展开参数包的方式实现的关键是逗号表达式。我们知道逗号表达式会按顺序执行逗号前面的表达式。
expand函数中的逗号表达式：(printarg(args), 0)，也是按照这个执行顺序，先执行printarg(args)，再得到逗号表达式的结果0。同时还用到了C++11的另外一个特性——初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)…}将会展开成((printarg(arg1),0),
(printarg(arg2),0), (printarg(arg3),0), etc… )，最终会创建一个元素值都为0的数组int arr[sizeof…(Args)]。
由于是逗号表达式，在创建数组的过程中会先执行逗号表达式前面的部分printarg(args)打印出参数，也就是说在构造int数组的过程中就将参数包展开了，这个数组的目的纯粹是为了在数组构造的过程展开参数包。
```cpp
template<class T>
void printarg(T value)
{
	cout << typeid(value).name() << ": " << value << endl;
}

template<class ...Args>
void ShowList(Args... args)
{
	int arr[] = { (printarg(args), 0)... };
	// 编译器需要计算数组的大小，后面调用函数，每次传递一个参数。由逗号表达式，最后数组值都是0
	// 三个点表示安装前面括号里面的方式依次展开
	for (int i = 0; i < 3; i ++ )
	{
		cout << arr[i] << " ";
	}
	cout << endl;
}

int main()
{
	//ShowList(1);
	//ShowList(1, 'A');
	ShowList(1, 'A', std::string("sort"));
	return 0;
}
```

### 61. lambda表达式
```cpp
[capture] (params) opt -> ret {};
```
其中carpture是捕获列表，params是参数，opt是选项，ret则是返回值的类型，body则是函数的具体实现。
   1. 捕获列表描述了lambda表达式可以访问上下文中的哪些变量： []：表示不捕获任何变量。 [=]：表示按值捕获变量，也就是说在lambda函数内使用lambda之外的变量时，使用的是拷贝。 [&]：表示按引用捕获变量，也就是说在lambda函数内使用lambda之外的变量时，使用的是引用。 [this]：值传递捕获当前的this。
   2. params表示lambda的参数，用在{}中。
   3. opt表示lambda的选项，例如mutable。
   4. ret表示lambda的返回类型，也可以显示指明返回类型，lambda会自动推断返回类型，但是值得注意的是只有当lambda的表达式仅有一条return语句时，自动推断才是有效的。