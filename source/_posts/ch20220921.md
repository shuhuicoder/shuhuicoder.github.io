---
title: 20220921_中移苏州面试总结
date: 2022-09-22 10:28:26
tags: [技术, 面试, C/C++]
categories: 日常
index_img: /img/cpplogo.jpg
banner_img: /img/default.png
author: shuhui
---
20220921中国移动苏州云能力中心面试总结

### 1. TCP/IP三次握手
    第一次握手：客户端向服务器端发起请求，发送SYN包和seq=x;
    第二次握手：服务器端受到客户端的SYN包，响应回复一个ACK=x+1包确认收到，同时发送自己的SYN(seq=y);
    第三次握手：客户端受到服务器的ACK和SYN，响应回复一个ACK=y+1向客户端确认收到
    完成三次握手，连接建立开始通信

### 2. C++四种强制类型转换
1. static_cast: ```static_cast<type_id->类型说明符>(expression->变量或表达式)```
   用于数据类型的强制转换，强制将一种数据类型转换为另一种数据类型；
   主要用法：
   1. 用于类层次结构中积累和派生类之间指针或引用的转换；
      1. 进行上行转换（把派生类的指针或引用转换为基类表示）是安全的；
      2. 进行下行转换（把基类的指针或引用转换为派生类表示）由于没有动态类型检查，是不安全的；
   2. 用于基本数据类型之间的转换，如int转换成char，这种转换也需要开发人员来保证；
   3. 把空指针转换成目标类型的空指针；
   4. 把任何类型的表达式转换为void类型；
   注意: 
        static_cast不能转换掉表达式中的const、volitale或者——unaligend属性
        如果涉及到类，只能在有相互联系的类型中精选相互转换，不一定包含虚函数
2. const_cast: ```const_cast<type_id>(expression)```
   1. const_cast用于强制去掉const这种不能被修改的常数特性，但是，const_cast不是用于去除变量的常量属性，而是去除指向常量对象的指针或引用的常量属性，其去除的对象必须是指针或引用;
   2. 可以用来修改类型的const和volatile属性，出来const或volatile修饰之外，type_id和expression的类型是一样的；
   3. 用法：
      - 常量指针被转化成非常量指针，并且仍然指向原来的对象；
      - 常量引用被转换成非常量引用，并且仍然指向原来的对象；
      - 常量对象被转换成非常量对象。
   4. 不建议使用const_cast去掉指针或引用的常量属性从而修改原始变量的数值；
3. reinterpret_cast: ```reinterpret_cast<type_id>(expression)```
   1. 在C++语言中，reinterpret_cast主要有三种强制转换用途：
        - 改变指针或引用的类型;
        - 将指针或引用转换为一个足够长度的整型;
        - 将整型转换为指针或引用类型。
    1. type-id必须是一个指针、引用、算术类型、函数指针或者成员指针
4. dynamic_cast: ```dynamic_cast<typr_id>(expression)```
   1. 其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。
   2. 不能用于内置的基本数据类型的强制转换。
   3. dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。
   4. 使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过。
        - 需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。
        - 这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表, 只有定义了虚函数的类才有虚函数表。
   5. 在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全
        - 向上转换，即为子类指针指向父类指针（一般不会出问题）；向下转换，即将父类指针转化子类指针。
        向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。
        在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。Dynamic_cast操作符则可以在运行期对可能产生问题的类型转换进行测试。
### 3. C++四种智能指针
1. 为什么需要智能指针？
   如果指针使用完忘记delete，将会造成内存泄漏，而使用智能指针时，当超出了智能指针类的作用域时，智能指针会自动调用析构函数，自动释放资源
2. 内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果;
3. auto_ptr:
   1. 采用独占式拥有模式，已被C++11弃用;
        ```cpp
        auto_ptr<string> p1(new string("hello"));
        auto_ptr<string> p2;
        p2 = p1;    // 可以通过
        // cout<<*p2<<endl;
        // cout<<*p1<<endl;     // 当程序运行时访问p1将会报错，因为所有权从p1转让给了p2，此时p1不再拥有该字符串对象从而变成空指针
        ```
4. unique_ptr:
   unique_ptr用于替换auto_ptr，实现了独占式拥有的概念，同时保证同一时间内只有一个智能指针可以指向该对象，因此，unique_ptr的拷贝构造函数和拷贝赋值构造函数均被声明为delete，无法实现拷贝和赋值操作，但可以通过移动构造和移动赋值操作，对于避免内存泄漏十分有效；
    ```cpp
    unique_ptr<string> p1(new string("hello"));
    unique_ptr<string> p2;
    p2 = p1;    // 此时无法通过编译
    // cout<<*p2<<endl;
    // cout<<*p1<<endl;
    ```
5. shared_ptr:
   1. shared_ptr实现共享式拥有的概念，通过引用计数，多个智能指针可以   指向相同的对象，该对象和其相关资源会在最后一个引用被销毁，即引用计数=0的时候释放。 
   2. 它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。
   3. 当复制一个shared_ptr，引用计数会+1。当我们调用release()或者当一个shared_ptr离开作用域时，计数减1（普通的指针如果没有delete操作，离开作用域时并不会被释放，只有在进程结束后才会被释放）。当计数等于0时，则delete内存。
   4. share_ptr的缺点为：当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏，此时需要使用weak_ptr；
   5. shared_ptr的安全性：
       - 引用计数增加是安全的，引用计数在堆上；
       - 不同线程同时操作一个shared_ptr的引用的不安全的；
       - 不同的shared_ptr指向同一块内存，操作同一个内存也是不安全的，即shared_ptr指向对象的读写并不是线程安全的；
   6. 智能指针shared_ptr的两种初始化方式:
        ```cpp
        shared_ptr<int> sp1(new int(10));   //通过new构造数据对象，调用了shared_ptr的构造函数
        shared_ptr<int> sp2 = make_shared<int>(10); //通过make_shared构造数据对象；
        ```
        1. 通过new构造，涉及到两次内存分配，第一次是通过new为数据对象分配内存，即上方的new int(10)，第二次是构造一个shared_ptr的管理对象，管理对象记录了强引用(shared_ptr)计数，弱引用(weak_ptr)计数，以及数据对象（new int(10)）的地址。当管理对象发现强引用计数为0时，释放数据对象的内存，当管理对象发现弱引用计数为0时，释放管理对象的内存;
        2. 通过make_shared构造，只分配一次内存，这一块内存里既包括管理对象，也包括数据对象。由于是在一块内存里，所以即使强引用计数已被清零，但如果弱引用计数还没有清零，那么也无法释放这一块内存，直到弱引用计数清零时，这一块内存（包括管理对象和数据对象）才能被释放。
        3. 构造函数是保护或私有时,无法使用 make_shared();
        4. share_ptr销毁了，但还有weak_ptr指向那个对象，weak_ptr怎么知道这个对象已销毁？
            - share_ptr销毁的时候，只是把指向的对象销毁了，而计数器Counter还没被销毁，Counter里面记录了share_ptr的引用计数以及weak_ptr的引用计数，weak_ptr可以通过查询Counter里面的值来知道对象已被销毁。当weak_ptr也小于1时，Counter才会被销毁。
6. weak_ptr:
   1. weak_ptr是用来解决shared_ptr相互引用时的死锁问题，如果两个shared_ptr相互引用，那么两个指针的引用计数将永远不可能下降为0，资源将永远得不到释放；
   2. weak_ptr是对对象的一种弱引用，不会增加对象的引用计数；
   3. weak_ptr可以和shared_ptr之间相互转化，shared_ptr可以直接赋值给weak_ptr, 而weak_ptr可以通过lock()函数来获得shared_ptr;
   4. 不能直接通过weak_ptr访问对象的方法，需要使用lock()函数转化成shared_ptr对象后再访问，weak_ptr没有重载```*```和```->```运算符。
        ```cpp
        #include <iostream>
        #include <memory>
        using namespace std;


        class B;	//声明
        class A
        {
        public:
            shared_ptr<B> pb_;
            void print()
            {
                cout<<"class A"<<endl;
            }
            ~A()
            {
                cout << "A delete\n";
            }
        };

        class B
        {
        public:
            // shared_ptr<A> pa_;
            weak_ptr<A> pa_;

            void print()
            {
                cout<<"class B"<<endl;
            }

            ~B()
            {
                cout << "B delete\n";
            }
        };

        void fun()
        {
            shared_ptr<B> pb(new B());
            shared_ptr<A> pa(new A());
            cout << pb.use_count() << endl;	//1
            cout << pa.use_count() << endl;	//1
            pb->pa_ = pa;
            pa->pb_ = pb;
            cout << pb.use_count() << endl;	//2
            cout << pa.use_count() << endl;	//2

            // pb->pa_->print();    // 报错
            pb->pa_.lock()->print();
            pa->pb_->print();
        }

        int main()
        {
            fun();

            return 0;
        }
        ```
### 5. 深拷贝和浅拷贝
1. 浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的；
2. 深拷贝：拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。
3. 在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。
4. 深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。

### 6. vector如何自动扩容
1. 整体的一个扩容流程为：申请新的内存空间（空间大小为原空间的两倍或一点五倍）—> 把原空间的元素拷贝到新的空间里 —> 释放原空间 —> 数组指针指向新空间。
2. 不同的的编译器实现方式不同,vs编译器每次是以1.5倍且向下取整的策略进行扩容，gcc编译器则是每次以2.0倍的策略进行扩容。
3. 扩充的过程并不是直接在原有空间后⾯追加容量，⽽是重新申请⼀块连续空间，将原有的数据拷⻉到新空间中，再释放原有空间，完成⼀次扩充。 需要注意的是，每次扩充是重新开辟的空间，所以扩充后，原有的迭代器将会失效;

### 7. 进程间通信的方式
1. 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
2. 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
3. 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
4. 共享内存SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
5. 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
6. 套接字Socket：套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机及其间的进程通信。
7. 信号 ( singal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。