---
title: Linux网络服务器编程03--socket使用流程、API以及数据的读写
date: 2023-06-30 09:54:59
tags: [C语言, 技术, 服务器编程, Linux]
categories: 服务器编程
index_img: /images/c_logo.jpg
banner_img: /images/c_codes.png
author: shuhui
---
### 1. socket的使用流程及相关API
1. 创建socket
```c
#include <sys/types.h>
#include <sys/socket.h>

int socket(int domain, int type, int protocol);
```
函数调用成功返回一个socket文件描述符，失败则返回-1并设置errno。
- domain: 使用的底层协议族，TCP/IP协议族设置为PF_INET或PF_INET6, 对于UNIX本地协议族则设置为PF_UNIX;
- type: 指定服务类型，主要有SOCK_STREAM流服务和SOCK_UGRAM数据报服务，对于TCP/IP协议族而言，分别对应表示传输层使用TCP协议和UDP协议; 在Linux内核2.6.17之后，type参数可以接受服务类型与阻塞标志相与的值，SOCK_NONBLOCK和SOCK_CLOEXEC。前者表示将新创建的socket设置为非阻塞状态，后者表示在用fork调用创建子进程时在子进程中关闭该socket;
- protocol: 表示在前两个参数构成的协议集合下，再选择一个具体的协议，该值通常已经被前两个参数决定为唯一值，一般设置为0，表示使用默认协议。

2. 命名(绑定)socket
在服务器端，通常需要将socket绑定到一个固定的地址和端口，而客户端程序则使用操作系统自动分配的地址。
```c
#include <sys/types.h>
#include <sys/socket.h>

int bind(int sockfd, const struct sockaddr* my_addr, socklen_t addrlen);
```

3. 监听socket
服务器在绑定socket之后并不能马上接受客户端连接，需要创建一个监听队列，存放待处理的客户端连接
```c
#include <sys/socket.h>

int listen(int sockfd, int backlog);
```
- backlog: 提示内核监听队列的最大长度，监听队列长度如果超过backlog，则服务器将不再受理新的连接，客户端也将收到ECONNREFUSED连接被拒绝的错误信息。backlog参数的典型值为5.

4. 接受socket连接
```c
#include <sys/types.h>
#include <sys/socket.h>

int accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen);
```
- addrlen: 表示socket地址的长度

5. 客户端发起连接
```c
#include <sys/types.h>
#include <sys/socket.h>

int connect(int sockfd, const struct sockaddr* serv_addr, socklen_t addrlen);
```
- serv_addr: 服务器的socket地址
- addrlen: 地址的长度

connect成功时返回0，表示成功与服务器建立连接，sockfd文件描述符则唯一标识该连接，客户端通过读写该文件描述符来与服务器进行通信。若连接失败，则返回-1并设置errno，常见的errno是ECONNREFUSED和ETIMEDOUT，前者表示目标地址和端口不存在，连接被拒绝；后者表示连接超时。

6. 关闭连接
```c
#include <unistd.h>

int close(int fd);
```
close并非总是立即关闭一个连接，而是将文件描述符fd的引用计数减1，只有当引用计数为0时，该连接才是真正被关闭。在多进程中，一次fork系统调用默认会将父进程中的socket引用计数加1，因此必须在父进程和子进程中都对socket进行close才能将连接关闭。
若要立即终止连接，可以使用shutdown：
```c
#include <sys/socket.h>

int shutdown(int sockfd, int howto);
```
- howto: 可选SHUT_RD, SHUT_WR, SHUT_RDWR. 分别表示关闭读端，关闭写端和同时关闭读写两端。
- 关闭读端时，不能再对socket进行读操作，且该socket接收缓冲区中的数据都将被丢弃；
- 关闭写端时，socket发送缓冲区中的数据会在真正关闭连接之前全部发送出去，不能再对其执行写操作，此时连接处于半关闭状态。

### 2. socket数据读写
对于文件的读写操作read和write同样可以适用于socket，但socket编程提供了几个专门用于socket数据读写的系统调用，并增加了对数据读写的控制。
1. TCP数据读写
```c
#include <sys/types.h>
#include <sys/socket.h>

ssize_t recv(int sockfd, void* buf, size_t len, int flags);

ssize_t send(int sockfd, const void* buf, size_t len, int flags);
```
- buf和flag分别指定缓冲区位置和大小，flags通常设置为0；

recv成功时返回实际读取到的数据的长度，可能小于期望的长度len，因此可能需要多次调用recv才能读取到完整的数据。recv可能返回0，表示通信对方可能已经关闭连接，当recv出错时，返回-1并设置errno；

send成功时返回实际写入的数据的长度，失败则返回-1并设置errno；

2. UDP数据读写
```c
#include <sys/types.h>
#include <sys/socket.h>

ssize_t recvfrom(int sockfd, void* buf, size_t len, int flags, struct sockaddr* src_addr, socklen_t* addrlen);

ssize_t sendto(int sockfd, const void* buf, size_t len, int flags, const struct sockaddr* dest_addr, socklen_t addrlen);
```
由于UDP没有连接的概念，因此每次读写数据时都需要指定对方的地址，即src_addr和dest_addr;

recvfrom和sendto也可以用于面向连接的数据读写，只需要将最后两个参数设置为NULL来忽略对方的地址即可，因此已经和对方建立了连接，因此已经知晓其地址。

3. 通用数据读写
socket编程接口还有一对通用的数据读写函数，都能够适用于TCP数据流服务和UDP数据报服务。
```c
#include <sys/socket.h>

ssize_t recvmsg(int sockfd, struct msghdr* msg, int flags);

ssize_t sendmsg(int sockfd, struct msghdr* msg, int flags);
```
- msg: 是msghdr结构体类型的指针，其定义如下：

```c
struct msghdr
{
    void* msg_name;         // socket地址
    socklen_t msg_namelen;  // socket地址的长度
    struct iovec* msg_iov;  // 分散的内存块
    int msg_iovlen;         // 分散内存块的数量
    void* msg_control;      // 指向辅助数据的其实位置
    socklen_t msg_controllen;   // 辅助数据的大小
    int msg_flags;          // 复制函数中的flags参数，并在调用过程中更新
};
```

- msg_name指向一个socket地址结构体变量，指定通信对方的socket地址，对于TCP该参数没有意义，设置为NULL；
- msg_iov是iovec结构体类型的指针，其定义如下：
```c
struct iovec
{
    void* iov_base;         // 内存起始地址
    size_t iov_len;         // 该内存块的长度
};
```

msg_iovlen指定了iovec结构对象的个数。对于recvmsg而言，数据将被读取并存放在msg_iovlen块分散的内存中，这些内存的位置和长度则有msg_iov指向的数组指定，这称之为分散读；对于sendmsg而言，msg_iovlen块分散内存中的数据将被一并发送，称之为集中写。
msg_control和msg_controllen则用于辅助数据的传送。

#### Reference
[1] Linux高性能服务器编程 游双著.