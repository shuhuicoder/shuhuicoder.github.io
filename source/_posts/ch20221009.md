---
title: 深入理解C++中的强制类型转换
date: 2022-10-09 10:32:05
tags: [C++]
categories: 技术
index_img: /img/cpplogo.jpg
banner_img: /images/2yy876.jpg
---
### 深入理解C++中的强制类型转换
C语言强制类型转换主要用于基础的数据类型间的转换，C++除了能使用c语言的强制类型转换外，还新增了四种强制类型转换：static_cast、dynamic_cast、const_cast、reinterpret_cast，主要运用于继承关系类间的强制转化.
#### 1. dynamic_cast
格式： `dynamic_cast < type-id > ( expression)`
将expression转换为type-id类型的对象，其中，type-id可以是类的指针、类的引用或者是void*， 如果type-id是类指针类型，则expression也必须是一个指针，如果type-id是一个类的引用，则expression也必须是一个引用。
作用：
dynamic_cast将一个基类对象的指针或引用转换到继承类指针或引用，其会根据基类指针是否真正指向继承类指针来作相应处理
- 若对类指针进行dynamic_cast，失败返回null, 成功则返回正常的cast之后的对象指针；
- 若对类引用进行dynamic_cast， 失败会抛出异常，成功则返回正常cast之后的对象引用；
注意：
- dynamic_cast在将父类cast到子类时，父类必须要有虚函数，否则编译器会报错。
- dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。
- 在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。
```cpp
#include <iostream>
#include <vector>
#include <assert.h>

using namespace std;

class People
{
private:
    string name;
    int age;

public:
    virtual void print()
    {
        cout << "class People: name=[" << name << "]"
             << "age=[" << age << "]" << endl;
    }
};

class Student : public People
{
private:
    int id;
    int classId;

public:
    int data;
    void print()
    {
        cout << "class Student: id=[" << id << "]"
             << "classId=[" << classId << "]" << endl;
    }
};

int main()
{
    People p;
    Student s;
    s.data = 100;

    People *pp;
    Student *ps;

    // 上行转换，没有问题，多态有效
    ps = &s;
    pp = dynamic_cast<People *>(ps);
    pp->print();

    // 下行转换: pp父类指针实际指向子类对象，没有问题
    pp = &s;
    ps = dynamic_cast<Student *>(pp);
    ps->print();
    cout << ps->data << endl;

    // 下行转换：pp实际指向父类对象，含有不安全操作，dynamic_cast发挥作用，返回NULL
    pp = &p;
    ps = dynamic_cast<Student *>(pp);
    assert(ps != NULL); // 违背断言，阻止以下不安全操作
    ps->print();
    cout << ps->data << endl; // 不安全操作，对象实例根本没有data成员

    // 下行转换：pp实际指向父类对象，含有不安全操作，static_cast无视
    pp = &p;
    ps = static_cast<Student *>(pp);
    assert(ps != NULL);
    ps->print();
    cout << ps->data << endl; // 不安全操作，对象实例根本没有data成员
}
```
#### 2. const_cast
const_cast是将常量转换成非常量，用于修改类型的const或volatile属性，不能对非指针或非引用的变量添加或移除const。
```cpp
#include <iostream>
using namespace std;

int main()
{
    const int g = 20;
    cout << g << endl;
    // int h = const_cast<int>(g); //不允许对普通数据进行操作
    int *h = const_cast<int *>(&g); //去掉const常量const属性
    cout << *h << endl;
    *h = 30;
    cout << *h << endl;

    const int g0 = 20;
    const int &g2 = g0;
    cout << g0 << endl;
    cout << g2 << endl;
    int &h1 = const_cast<int &>(g0); //去掉const引用const属性
    int &h2 = const_cast<int &>(g2); //去掉const引用const属性
    cout << h1 << endl;
    cout << h2 << endl;
    h1 = 30;
    h2 = 30;
    cout << h1 << endl;
    cout << h2 << endl;

    const char *g1 = "hello";
    char *h3 = const_cast<char *>(g1); //去掉const指针const属性
    cout << h3 << endl;
    char g3[] = "world";
    h3 = g3;
    cout << h3 << endl;
}
```
#### 3. static_cast 静态转换
static_cast静态转换相当于C语言中的强制转换，但不能实现普通指针数据（空指针除外）的强制转换，一般用于父类和子类指针、引用间的相互转换。
1. 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。不管是否发生多态，父子之间互转时，编译器都不会报错。
- 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；
- 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的，但是编译器不会报错。
2. 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
3. 把空指针转换成目标类型的空指针。
4. 把任何指针类型转换成空指针类型。
5. 可以对普通数据的const和non_const进行转换，但不能对普通数据取地址后的指针进行const添加和消去。
6. 无继承关系的自定义类型，不可转换，不支持类间交叉转换。
注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性
```cpp
class Person{

};

class Son :public Person{

};

class My{};

void test02(){
    char a = 'c';
    int b = static_cast<int> (a);
    cout << b << endl;

    const char a0 = 'c';
    char b0 = static_cast<char> (a0);
    cout << b0 << endl;

    char a1 = 'c';
    const char b1 = static_cast<const char> (a1);
    cout << b1 << endl;

    //static无法丢掉常量或其他类型限定符，只限于对常量地址的指针去const
    //const char a2 = 'c';
    //char *b2 = static_cast<char*> (&a2);
    //cout << b2 << endl;


    //父类指针转为子类
    Person *p = NULL;
    Son *s = static_cast<Son*>(p);

    //子类指针转为父类
    Son *s0 = NULL;
    Person *p0 = static_cast<Person*>(s0);

    //My* my= static_cast<My*>(p); 无继承关系的自定义数据类型不能相互转换

    //父类对象无法转为子类对象
    //Person p1;
    //Son s1 = static_cast<Son>(p1);

    //子类对象可以赋值，初始化父类对象
    Son s2;
    Person p2 = static_cast<Person>(s2);

    //父类引用转为子类
    Person p_ ;
    Person &p3 = p_;
    Son &s3 = static_cast<Son&>(p3);

    //子类引用转为父类
    Son s_;
    Son &s4 = s_;
    Person &p4 = static_cast<Person&>(s4);

    //空指针转化为目标类型的指针
    void *pPtr = NULL;
    int *iPtr = static_cast<int*>(pPtr);

    //任何指针转化为空指针类型
    int *aInt = NULL;
    void *aVoid = static_cast<void*>(aInt);

    //static_cast不能进行出void外的指针强制互转
    char *tmp = "abc";
    cout << tmp << endl;

    //cout << static_cast<int*>(tmp) << endl;不能将char*型的数据转换为int*，但C语言强转可以
    cout << static_cast<void*>(tmp) << endl;

    int *tmp_ = (int*)(tmp);
    cout << static_cast<int*>(tmp_) << endl;

    int *tmpInt = 0;
    cout << tmpInt << endl;
    cout << static_cast<void*>(tmpInt) << endl;
    cout << static_cast<int*>(tmpInt) << endl;//转为自身可以
}
```
#### 4. reinterpret_cast 重新解释转换
最鸡肋的转换函数，可以将任意类型转换为任意类型，因此非常不安全。只有将转换后的类型值转换回到其原始类型，这样才是正确使用reinterpret_cast方式