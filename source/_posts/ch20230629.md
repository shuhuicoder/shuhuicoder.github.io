---
title: Linux网络服务器编程02--关于socket地址及API
date: 2023-06-29 23:02:40
tags: [C语言, 技术, 服务器编程, Linux]
categories: 服务器编程
index_img: /images/c_logo.jpg
banner_img: /images/c_codes.png
author: shuhui
---
### 1. 关于socket地址
#### 1.1 通用socket地址
socket网络编程中表示socket地址的是结构体sockaddr；
```c
#include <bits/socket.h>

struct sockaddr
{
    sa_family_t safamily;       // 地址族类型sa_family_t
    char sa_data[14];           // 用于存放socket地址值，仅14字节
}
```
由于14字节的sa_data无法容纳多数协议族的地址值，因此Linux定义了新的通用socket地址结构体；
```c
#include <bits/socket.h>

struct sockaddr_storage
{
    sa_family_t sa_family;
    unsigned long int __ss_align;
    char __ss_padding[128-sizeof(__ss_align)];
}
```
该结构体不仅提供了足够大的空间用于存放地址值，并且由于__ss_align的作用，其是内存对齐的。

#### 1.2 专用socket地址
由于通用的socket地址结构体不好用，在设置和获取IP地址和端口号时较为繁琐，因此Linux为各个协议族协议提供了专门的socket结构体。
Unix本地域协议族通常使用如下专用结构体：
```c
#include <sys/un.h>

struct sockaddr_un
{
    sa_family_t sin_family;     // 地址协议族：AF_UNIX
    char sun_path[108];         // 文件路径名
}
```
TCP/IP协议族则有sockaddr_in 和 sockaddr_in6 两个专用socket地址结构体，分别用于IPv4和IPv6。
```c
struct sockaddr_in
{
    sa_family_t sa_family;      // 地址协议族：AF_INET
    u_int16_t sin_port;         // 端口号，需要用网络字节序表示
    struct in_addr sin_addr;    // IPv4结构体
};

// IPv4结构体
struct in_addr
{
    u_int32_t s_addr;           // IPv4地址，需要用网络字节序表示
};
```
```c
struct sockaddr_in6
{
    sa_family_t sin6_family;    // 地址协议族：AF_INET6
    u_int16_t sin6_port;        // 端口号，需要用网络字节序表示
    u_int32_t sin6_flowinfo;    // 流信息，应设置为0
    struct in6_addr sin6_addr;  // IPv6地址结构体
    u_int32_t sin6_scope_id;    // scope ID, 暂时处于实验阶段，不使用
};

// IPv6地址结构体
struct in6_addr
{
    unsigned char sa_addr[16];  // IPv6地址，需要用网络字节序表示
};
```

### 2. IP地址转换
下列3个函数能够用于点分十进制字符串表示的IPv4地址与用网络字节序整数表示的IPv4地址之间的转换：
```c
#include <arpa/inet.h>

// 将点分十进制字符串的地址转换为网络字节序整数地址, 失败时返回INADDR_NONE
in_addr_t inet_addr(const char* strptr);

// 作用与inet_addr一样，但会将转换的结果存储于inp所指向的地址结构体中，成功返回1，失败返回0；
int inet_aton(const char* cp, struct in_addr* inp);

// 将网络字节序表示的地址转为点分十进制字符串
char* inet_ntoa(struct in_addr in);
```
NOTE: 需要注意的是，inet_ntoa内部是使用一个静态变量存储转换的结果，函数的返回值则指向该静态内存，因此inet_ntoa是不可重入的，即当再次调用该函数时，静态变量内存中的结果将被新的覆盖。
例如：
```c
#include <stdio.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>

int main()
{

    struct in_addr addr1 = {0x8417a8c0};    // 192.168.23.132 反转后的16进制
    struct in_addr addr2 = {0xb90d190a};    // 10.25.13.185 反转后的16进制

    char* value1 = inet_ntoa(addr1);
    char* value2 = inet_ntoa(addr2);

    printf("addr 1: %s\n", value1);         // addr 1: 10.25.13.185
    printf("addr 2: %s\n", value2);         // addr 2: 10.25.13.185

    return 0;
}
```

以下更新的函数也能实现与前述3个函数一样的功能，并且能够同时适用于IPv4和IPv6地址：
```c
#include <arpa/inet.h>

// 将使用点分十进制字符串（IPv4）或十六进制字符串（IPv6）表示的IP地址src 转换为网络字节序表示的IP地址，并将转换结果存储于dst所指向的内存中，其中，af指定地址族，AF_INET或者AF_INET6。函数成功返回1，失败返回0并设置errno。
int inet_pton(int af, const char* src, void* dst);

// 执行相反的转换，参数类似，其中，cnt指定目标存储单元的大小。函数成功返回目标存储单元的地址，失败则返回NULL并设置errno
const char* inet_ntop(int af, const void* src, char* dst, socklen_t cnt);
```
其中下列宏能够为cnt指定大小：
```c
#include <netinet/in.h>

#define INET_ADDRSTRLEN 16
#define INET6_ADDRSTRLEN 46
```


#### Reference
[1] Linux高性能服务器编程 游双著.