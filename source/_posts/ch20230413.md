---
title: Linux网络服务器编程01--关于主机字节序和网络字节序
date: 2023-04-13 15:16:47
tags: [C语言, 技术, 服务器编程, Linux]
categories: 服务器编程
index_img: /images/c_logo.jpg
banner_img: /images/c_codes.png
author: shuhui
---
### 1. 基础知识
由于现代CPU的累加器一次能够装载至少4字节(在32位机环境下)，即一个整数。该4字节在内存中的排列顺序便会影响到其被累加器装载时所生成的整数值，这就是字节序问题。字节序分为大端字节序（big endian）和小端字节序（little endian）。
- 大端字节序：
    一个整数的高位字节(23-31 bit)存储在内存的低地址处，而低位字节(0-7 bit)存储在内存的高地址处；
- 小端字节序：
    指整数的高位字节存储在内存的高地址处，而低位字节存储在内存的低地址处。
由于现代PC大多采用小端字节序，因此小端字节序也被成为“主机字节序”。当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端不进行转换的话必然会导致错误解释。因此，解决问题的方法是：发送端总是将要发送的数据转化成大端字节序数据后再进行发送，而接收端由于知道发送方总是采用大端字节序，所以接收端便可以根据自身所采用的字节序来决定是否对收到的数据进行转换。因此，大端字节序也被称为“网络字节序”，其为所有接收数据的主机提供了一个正确解析收到的格式化数据的保证。
NOTE：即便是同一台机器上的两个进程之间（比如一个是C语言程序，另一个是Java语言程序）通信，也需要考虑字节序问题，例如Java虚拟机便是采用大端字节序。

### 2. API函数
Linux环境中提供了如下4个函数来完成主机字节序和网络字节序之间的转换。
```c
#include <netinet/in.h>

unsigned long int htonl(unsigned long int hostlong);

unsigned short int htons(unsigned short int hostshort);

unsigned long int ntohl(unsigned long int netlong);

unsigned short int ntohs(unsigned short int netshort);
```
上述API函数含义很明确，例如 htonl 即表示“host to network long”，即将长整型(32 bit)的主机字节序转换成网络字节序数据。
在4个函数中，长整型函数通常用来转换IP地址，而短整型则用来转换端口号。当然不限于此，任何格式化数据通过网络传输时，都应该使用这些函数来转换字节序。

### 3. 判断机器字节序
如下代码可以用来检查所使用机器的字节序：
```c
#include <stdio.h>

void byteorder()
{
	union{
		short value;
		char union_bytes[sizeof(short)];
	}test;
	
	test.value = 0x0102;
	
	if((test.union_bytes[0] == 1) && (test.union_bytes[1] == 2))
	{
		printf("Big endian!\n");
	}
	else if((test.union_bytes[0] == 2) && (test.union_bytes[1] == 1))
	{
		printf("Little endian!\n");
	}
	else
	{
		printf("Unkown...\n");
	}
}

int main()
{
	byteorder();
	return 0;
}
```
