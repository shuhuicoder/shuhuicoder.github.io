---
title: C++实现单/双链表的反转以及复制
date: 2022-10-12 11:51:50
tags: [技术, C++]
categories: 技术
index_img: /img/cpplogo.jpg
banner_img: /images/5g7ew7.jpg
author: shuhui
---
### 1. 构建单向链表
```cpp
struct ListNode
{
    int val;
    ListNode* next;
    ListNode():val(0), next(nullptr){}
    ListNode(int x):val(x), next(nullptr){}
    ListNode(int x, ListNode* next):val(x), next(next){}
};

ListNode* constructList(vector<int>& nums)
{
    ListNode* dummy = new ListNode(0);
    ListNode* cur = dummy;
    for(int i : nums)
    {
        cur->next = new ListNode(i);
        cur = cur->next;
    }
    ListNode* head = dummy->next;
    delete dummy;
    return head;
}
```
### 2. C++反转单向链表的四种方式
#### 1. 迭代法
```cpp
// 迭代方法
ListNode* reverseList_1(ListNode* head)
{
    ListNode* prev = nullptr;
    ListNode* next = nullptr;
    ListNode* cur = head;
    while(cur!=nullptr)
    {
        // 先保存当前节点的下一个节点;
        next = cur->next;
        // 将当前节点的下一个指向它的前一个;
        cur->next = prev;
        // 将当前节点作为前置节点
        prev = cur;
        // 当前节点移动至保存的下一节点
        cur = next;
    }
    return prev;
}
```

#### 2. 递归方法
```cpp
// 递归方法
ListNode* reverseList_2(ListNode* head)
{
    // 递归出口, 当空链表或者只有一个节点时,直接返回
    if(head == nullptr || head->next == nullptr)
    {
        return head;
    }
    // 一直递归找到链表中的最后一个节点
    ListNode* newHead = reverseList_2(head->next);
    // 在两个节点之间交换,第一个节点的next就是第二个节点,因此head->next->next就是第二个节点的next指针,将其指向第一个节点head
    head->next->next = head;
    // 将第一个节点的next置为null
    head->next = nullptr;
    // 每一层递归结束,将新的头节点返回给上一层,保证整个递归过程能够一直找到新链表的表头
    return newHead;
}
```

#### 3. 头插法
在原有链表的基础上,依次将位于链表头部的节点摘下,然后采用从头部插入的方式生成一个新链表,生成的新链表即为原链表的反转;
```cpp
ListNode* reverseList_3(ListNode* head)
{
    if(head == nullptr || head->next == nullptr)
    {
        return head;
    }
    ListNode* newHead = nullptr;
    ListNode* temp = nullptr;
    while(head != nullptr)
    {
        temp = head;
        // 将头节点从原链表中摘下
        head = head->next;
        // 将temp插入到newHead的头部
        temp->next = newHead;
        // 头部往前移动
        newHead = temp;
    }
    return newHead;
}
```

#### 4. 原地反转
与头插法类似,区别在于不需要建立一个新链表,而是直接对原链表做修改来实现,需要两个辅助指针
```cpp
ListNode* reverseList_4(ListNode* head)
{
    if(head == nullptr || head->next == nullptr)
    {
        return head;
    }
    ListNode* begin = head;
    ListNode* end = head->next;
    while (end != nullptr)
    {
        // 将第一个节点的下一个指向end的下一个,即第三个节点,
        begin->next = end->next;
        // 将end即第二个节点插入到头节点的前面
        end->next = head;
        // 将插入的新节点作为新的头节点
        head = end;
        // 第一个节点的下一个作为第二个节点, 而begin始终都是原来的第一个节点,或者说是原始头节点
        end = begin->next;
    }
    // 返回新的头节点
    return head;
}
```
### 3. 构建双向链表
双向链表与单向链表的不同在于,双向链表多了一个指向直接前驱节点的prev指针
```cpp
struct DoubleListNode
{
    int val;
    DoubleListNode *next;
    DoubleListNode *prev;
    DoubleListNode() : val(0), next(nullptr), prev(nullptr) {}
    DoubleListNode(int x) : val(x), next(nullptr), prev(nullptr) {}
    DoubleListNode(int x, DoubleListNode *next, DoubleListNode *prev) : val(x), next(next), prev(prev) {}
};

DoubleListNode *constructDoubleList(vector<int> &nums)
{
    DoubleListNode *dummy = new DoubleListNode(0);
    DoubleListNode *cur = dummy;
    for (int i : nums)
    {
        DoubleListNode *node = new DoubleListNode(i);
        cur->next = node;
        node->prev = cur;
        cur = cur->next;
    }
    DoubleListNode *head = dummy->next;
    head->prev = nullptr;
    delete dummy;
    return head;
}
```
### 4. 双向链表的反转
```cpp
DoubleListNode *reversList(DoubleListNode *head)
{
    if (head == nullptr || head->next == nullptr)
    {
        return head;
    }
    DoubleListNode *prev = nullptr;
    DoubleListNode *next = nullptr;
    while (head != nullptr)
    {
        next = head->next;
        head->next = prev;
        head->prev = next;
        prev = head;
        head = next;
    }
    return prev;
}
```
