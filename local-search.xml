<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ch20230713-01</title>
    <link href="/2023/07/15/ch20230713-01/"/>
    <url>/2023/07/15/ch20230713-01/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在Windows10中安装WSL1&amp;2，并配置C/C++和VSCode环境</title>
    <link href="/2023/07/13/ch20230713/"/>
    <url>/2023/07/13/ch20230713/</url>
    
    <content type="html"><![CDATA[<p>在WIndows中使用WSL来创建Linux子系统，并通过VSCode来进行连接方便本地开发和调试，虽然在微软的应用商店就可以直接下载Ubuntu等子系统WSL，但是却并没有CentOS系统的相关应用下载，因此需要自己进行安装配置。</p><p>WSL分为版本1和版本2，使用两个都可以，但是我在实际安装时，在使用VSCode连接WSL1的CentOS时，会出现VSCode扩展插件无法安装到子系统的问题，具体是报类似“EACCES: Permission Denied, rename”的错误；因此，我一直无法解决，于是后面我则是将WSL升级到版本2，则不再有此类问题。文章后面也会提到升级的方法。</p><h3 id="1-在Windows中使用-WSL-1-来安装CentOS子系统"><a href="#1-在Windows中使用-WSL-1-来安装CentOS子系统" class="headerlink" title="1. 在Windows中使用 WSL 1 来安装CentOS子系统"></a>1. 在Windows中使用 WSL 1 来安装CentOS子系统</h3><h4 id="1-在Windows10中开启WSL功能"><a href="#1-在Windows10中开启WSL功能" class="headerlink" title="1. 在Windows10中开启WSL功能"></a>1. 在Windows10中开启WSL功能</h4><ul><li><ol><li>以管理员身份运行PowerShell</li></ol></li><li><ol start="2"><li>在PowerShell中输入如下命令，命令将会输出系统的相关信息，目的是查看系统是否支持使用WSL功能；一般系统版本高于1709的都能支持；<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Get-ComputerInfo | Select WindowsProductName, WindowsVersion, WindowsInstallationType, OsServerLevel, OsVersion, OsHardwareAbstractionLayer<br></code></pre></td></tr></table></figure></li></ol></li><li><ol start="3"><li>继续在Power Shell中输入如下命令，来开启WSL功能，如果已经启用过了，则不会要求重启电脑；否则输入<code>y</code>并回车，来选择重启电脑以使功能生效；  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux<br></code></pre></td></tr></table></figure></li></ol></li></ul><h4 id="2-在WSL中安装CentOS7"><a href="#2-在WSL中安装CentOS7" class="headerlink" title="2. 在WSL中安装CentOS7"></a>2. 在WSL中安装CentOS7</h4><ul><li><ol><li>下载一个可用于WSL的CentOS镜像，<a href="https://github.com/wsldl-pg/CentWSL">GitHub中有一个开源的CenOS可用实例</a>；下载后解压将会看到2个文件：<code>rootfs.tar.gz</code>和<code>CentOS7.exe</code>；</li></ol></li><li><ol start="2"><li>右键CenOS.exe以管理员身份运行，将该系统安装到WSL，稍等一会后，将会在程序安装的界面中看到<code>Installation Complete</code>的字样，则表明安装完成，按任意键即可退出安装；</li></ol></li><li><ol start="3"><li>返回安装目录，可以发现多出了两个<code>rootfs</code>和<code>temp</code>两个目录，其中，<code>rootfs</code>内部就是CentOS内部的根目录及其相关的文件；随后再次右键运行<code>CentOS7.exe</code>，即可进入WSL中的CentOS系统；</li></ol></li></ul><h4 id="3-在WSL中更新CentOS7"><a href="#3-在WSL中更新CentOS7" class="headerlink" title="3. 在WSL中更新CentOS7"></a>3. 在WSL中更新CentOS7</h4><p>在WSL的CentOS7系统中键入如下命令即可对系统进行更新；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y update<br></code></pre></td></tr></table></figure><h4 id="4-卸载或删除CentOS7"><a href="#4-卸载或删除CentOS7" class="headerlink" title="4. 卸载或删除CentOS7"></a>4. 卸载或删除CentOS7</h4><p>在CentOS7的安装目录中，即一开始的解压目录中，在该目录下以管理员身份打开Power shell，并运行如下命令，即可清理安装的CentOS7；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./CentOS7.exe clean<br></code></pre></td></tr></table></figure><h3 id="2-升级使用WSL-2"><a href="#2-升级使用WSL-2" class="headerlink" title="2. 升级使用WSL 2"></a>2. 升级使用WSL 2</h3><h4 id="1-下载WSL2-Linux-内核更新包"><a href="#1-下载WSL2-Linux-内核更新包" class="headerlink" title="1. 下载WSL2 Linux 内核更新包"></a>1. 下载WSL2 Linux 内核更新包</h4><ul><li><ol><li>通过链接地址来<a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">下载WSL 2的更新包</a></li></ol></li><li><ol start="2"><li>运行下载的更新包</li></ol></li></ul><p>安装完成后，可以选择将WSL 2设置为默认版本，如果希望继续使用WSL 1则跳过该步骤;</p><h4 id="2-将WSL-2设置为默认版本"><a href="#2-将WSL-2设置为默认版本" class="headerlink" title="2. 将WSL 2设置为默认版本"></a>2. 将WSL 2设置为默认版本</h4><p>打开PowerShell，并运行以下命令，将WSL 2设置为默认使用版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">WSL --set-default-version 2<br></code></pre></td></tr></table></figure><h4 id="3-安装CentOS7"><a href="#3-安装CentOS7" class="headerlink" title="3. 安装CentOS7"></a>3. 安装CentOS7</h4><p>这里就和前面安装的步骤一样</p><h3 id="3-配置C-x2F-C-和VSCode环境"><a href="#3-配置C-x2F-C-和VSCode环境" class="headerlink" title="3. 配置C&#x2F;C++和VSCode环境"></a>3. 配置C&#x2F;C++和VSCode环境</h3><ul><li><ol><li>CentOS中安装GCC, G++  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y gcc-c++<br></code></pre></td></tr></table></figure></li></ol></li><li><ol start="2"><li>Windows本机中安装VSCode，然后首先是在本地安装<code>C/C++ Extension Pack</code>, 即C&#x2F;C++的相关扩展插件，然后安装远程连接相关的扩展插件，包括<code>Remote-SSH, Remote Explorer, WSL</code>; 如果没有安装远程连接的相关插件，在将C&#x2F;C++插件安装到WSL子系统中时会报错，即前面所说的类似错误；</li></ol></li><li><ol start="3"><li>在VSCode中选择远程连接到WSL，然后在CentOS子系统中安装C&#x2F;C++的相关扩展插件；这样做的目的是通过VSCode来连接到子系统方便编写、编译和调试代码，而在WSL中安装这些插件也可以使得在编写代码的过程中能够自动补全代码。</li></ol></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol><li><a href="https://learn.microsoft.com/zh-cn/windows/wsl/basic-commands?redirectedfrom=MSDN">WSL 的基本命令</a></li><li><a href="https://learn.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package">旧版 WSL 的手动安装步骤</a></li><li><a href="https://zhuanlan.zhihu.com/p/271927065">漫谈在Windows Server 2019中安装使用WSL</a> </li><li><a href="https://zhuanlan.zhihu.com/p/272735470">在Windows 10上使用WSL安装Centos</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux网络服务器编程05--关于带外标记和发送接收带外数据的方法</title>
    <link href="/2023/06/30/ch20230630-02/"/>
    <url>/2023/06/30/ch20230630-02/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是带外数据"><a href="#1-什么是带外数据" class="headerlink" title="1. 什么是带外数据"></a>1. 什么是带外数据</h3><p>在某些传输层系统中具有带外(Out of Band)数据的概念，其是用来迅速告知对方本端发生的重要事件。因此，带外数据要比普通数据(或称为带内数据)具有更高的优先级，它应该被立即发送，而不论发送缓冲区中是否有排队等候发送的普通数据。</p><p>带外数据的传输既可以使用一条独立的传输层连接，也可以映射到普通数据的连接中。实际应用中，带外数据的使用比较少见，已知的仅有telnet、ftp等远程非活跃程序。</p><p>UDP中并没有实现带外数据传输，而TCP也没有真正的带外数据，但TCP中利用其头部中的紧急指针标志和紧急指针两个字段，为应用程序提供了一种紧急方式。该方式利用传输普通数据的连接来传输紧急数据，这种紧急数据的含义和带外数据类似，因此也将TCP紧急数据称为带外数据。</p><h3 id="2-TCP发送带外数据的过程"><a href="#2-TCP发送带外数据的过程" class="headerlink" title="2. TCP发送带外数据的过程"></a>2. TCP发送带外数据的过程</h3><p><img src="/2023/06/30/ch20230630-02/tcpOutofBand.png" alt="TCP带外数据"><br>如图，假设TCP的发送缓冲区中已经写入了N字节的普通数据，并等等发送，在数据被发送前，又向该连接写入了3字节的带外数据”abc”, 此时，待发送的TCP报文段头部将被设置URG标志，并且紧急指针被设置为指向最后一个带外数据的下一个字节（进一步减去当前TCP报文段的序号值得到其头部中的紧急偏移值）。</p><p>由图中可见，发送端一次发送的多字节的带外数据中，只有最后一个字节被当作是带外数据，即字母c；而其他数据（字母a和b）则被当成了普通数据。若TCP模块以多个TCP报文段来发送缓冲区中的内容，则美国TCP报文段都将被设置URG标志，且它们的紧急指针将指向同一个位置，即数据流中带外数据的写一个位置），但实际只有一个TCP报文段是真正携带带外数据。</p><p>在TCP接收端，只有在接收到紧急指针标志时才会坚持紧急指针，并根据紧急指针所指的位置确定带外数据的位置，并将其读入到一个特殊的缓冲区中。其中，该缓冲区只有1字节，称为带外缓存。如果上传应用没有及时将带外数据从该缓存中读取，则后续的带外数据将覆盖它。</p><p>上述为TCP模块接收带外数据的默认方式。实际上，如果给TCP连接设置了SO_OOBINLINE选项，则带外数据将和普通数据一样，被存放在TCP接收缓冲区中，此时，应用程序需要向读取普通数据一样来读取带外数据，然后对其进行区分。</p><h3 id="3-TCP实现带外数据的发送和接收"><a href="#3-TCP实现带外数据的发送和接收" class="headerlink" title="3. TCP实现带外数据的发送和接收"></a>3. TCP实现带外数据的发送和接收</h3><p>用于TCP数据读写的系统调用为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recv</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span>* buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags)</span>;<br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure><p>其中flags参数为数据收发提供了额外的控制，其可以取如下表格中的一个或多个的逻辑或。<br><img src="/2023/06/30/ch20230630-02/recv_send_flags.png" alt="flags参数选项表格"><br>表中MSG_OOB选项就给应用程序提供了发送和接收带外数据的方法。</p><ul><li><p>发送带外数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt;= <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: %s ip_address, port_number\n&quot;</span>, basename(argv[<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> port = atoi(argv[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_address</span>;</span><br>    bzero(&amp;server_address, <span class="hljs-keyword">sizeof</span>(server_address));<br>    server_address.sin_family = AF_INET;<br>    inet_pton(AF_INET, ip, &amp;server_address.sin_addr);<br>    server_address.sin_port = htons(port);<br><br>    <span class="hljs-type">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    assert(sockfd &gt;= <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span>(connect(sockfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;server_address, <span class="hljs-keyword">sizeof</span>(server_address)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connection failed\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* oob_data = <span class="hljs-string">&quot;abc&quot;</span>;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* normal_data = <span class="hljs-string">&quot;123&quot;</span>;<br><br>        send(sockfd, normal_data, <span class="hljs-built_in">strlen</span>(normal_data), <span class="hljs-number">0</span>);<br>        send(sockfd, oob_data, <span class="hljs-built_in">strlen</span>(oob_data), MSG_OOB);<br>        send(sockfd, normal_data, <span class="hljs-built_in">strlen</span>(normal_data), <span class="hljs-number">0</span>);<br>    &#125;<br><br>    close(sockfd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接收带外数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 1024</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt;= <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: %s ip_address, port_number\n&quot;</span>, basename(argv[<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> port = atoi(argv[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    bzero(&amp;address, <span class="hljs-keyword">sizeof</span>(address));<br>    address.sin_family = AF_INET;<br>    inet_pton(AF_INET, ip, &amp;address.sin_addr);<br>    address.sin_port = htons(port);<br><br>    <span class="hljs-type">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    assert(sockfd &gt;= <span class="hljs-number">0</span>);<br><br>    <span class="hljs-type">int</span> ret = bind(sockfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;address, <span class="hljs-keyword">sizeof</span>(address));<br>    assert(ret != <span class="hljs-number">-1</span>);<br><br>    ret = listen(sockfd, <span class="hljs-number">5</span>);<br>    assert(ret != <span class="hljs-number">-1</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-type">socklen_t</span> client_addrlen = <span class="hljs-keyword">sizeof</span>(client);<br>    <span class="hljs-type">int</span> connfd = accept(sockfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;client, &amp;client_addrlen);<br><br>    <span class="hljs-keyword">if</span>(connfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">char</span> buffer[BUF_SIZE];<br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE);<br>        ret = recv(connfd, buffer, BUF_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;got %d bytes of normal data &#x27;%s&#x27; \n&quot;</span>, ret, buffer);<br><br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE);<br>        ret = recv(connfd, buffer, BUF_SIZE<span class="hljs-number">-1</span>, MSG_OOB);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;got %d bytes of oob data &#x27;%s&#x27; \n&quot;</span>, ret, buffer);<br><br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE);<br>        ret = recv(connfd, buffer, BUF_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;got %d bytes of normal data &#x27;%s&#x27; \n&quot;</span>, ret, buffer);<br><br>        close(connfd);<br>    &#125;<br><br>    close(sockfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>首先运行接收端程序<code>./recv.exe ip port</code>, 例如：<code>./recv.exe 192.168.23.132 54321</code>;</p></li><li><p>然后运行发送端程序<code>./send.exe ip port</code>, 例如：<code>./send.exe 192.168.23.132 54321</code>;</p></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] Linux高性能服务器编程 游双著.</p>]]></content>
    
    
    <categories>
      
      <category>服务器编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>C语言</tag>
      
      <tag>Linux</tag>
      
      <tag>服务器编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux网络服务器编程04--socket简单TCP服务器和客户端实现</title>
    <link href="/2023/06/30/ch20230630-01/"/>
    <url>/2023/06/30/ch20230630-01/</url>
    
    <content type="html"><![CDATA[<p>这里简单使用socket编程实现TCP数据流的服务器端和客户端之间的通信流程。</p><h3 id="1-服务器端程序"><a href="#1-服务器端程序" class="headerlink" title="1. 服务器端程序"></a>1. 服务器端程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//服务端程序</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">//创建socket</span><br><span class="hljs-comment">//int socket(int domain, int type, int protocol);</span><br><span class="hljs-type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>(lfd&lt;<span class="hljs-number">0</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;socket error&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">//int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="hljs-comment">//绑定</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv</span>;</span><br>bzero(&amp;serv, <span class="hljs-keyword">sizeof</span>(serv));<br>serv.sin_family = AF_INET;<br>serv.sin_port = htons(<span class="hljs-number">8888</span>);<br>serv.sin_addr.s_addr = htonl(INADDR_ANY); <span class="hljs-comment">//表示使用本地任意可用IP</span><br><span class="hljs-type">int</span> ret = bind(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv, <span class="hljs-keyword">sizeof</span>(serv));<br><span class="hljs-keyword">if</span>(ret&lt;<span class="hljs-number">0</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;bind error&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">//监听</span><br><span class="hljs-comment">//int listen(int sockfd, int backlog);</span><br>listen(lfd, <span class="hljs-number">128</span>);<br><br><span class="hljs-comment">//int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br><span class="hljs-type">socklen_t</span> len = <span class="hljs-keyword">sizeof</span>(client);<br><span class="hljs-type">int</span> cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client, &amp;len);  <span class="hljs-comment">//len是一个输入输出参数</span><br><span class="hljs-comment">//const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</span><br><br><span class="hljs-comment">//获取client端的IP和端口</span><br><span class="hljs-type">char</span> sIP[<span class="hljs-number">16</span>];<br><span class="hljs-built_in">memset</span>(sIP, <span class="hljs-number">0x00</span>, <span class="hljs-keyword">sizeof</span>(sIP));<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client--&gt;IP:[%s],PORT:[%d]\n&quot;</span>, <br>    inet_ntop(AF_INET, &amp;client.sin_addr.s_addr, <br>    sIP, <span class="hljs-keyword">sizeof</span>(sIP)), ntohs(client.sin_port));<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;lfd==[%d], cfd==[%d]\n&quot;</span>, lfd, cfd);<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">//读数据</span><br><span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0x00</span>, <span class="hljs-keyword">sizeof</span>(buf));<br>n = read(cfd, buf, <span class="hljs-keyword">sizeof</span>(buf));<br><span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read error or client close, n==[%d]\n&quot;</span>, n);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n==[%d], buf==[%s]\n&quot;</span>, n, buf);<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>&#123;<br>buf[i] = <span class="hljs-built_in">toupper</span>(buf[i]);<br>&#125;<br><br><span class="hljs-comment">//发送数据</span><br>write(cfd, buf, n);<br>&#125;<br><br><span class="hljs-comment">//关闭监听文件描述符和通信文件描述符</span><br>close(lfd);<br>close(cfd);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-客户端程序"><a href="#2-客户端程序" class="headerlink" title="2. 客户端程序"></a>2. 客户端程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//客户端代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">//创建socket---用于和服务端进行通信</span><br><span class="hljs-type">int</span> cfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>(cfd&lt;<span class="hljs-number">0</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;socket error&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">//连接服务端</span><br><span class="hljs-comment">//int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv</span>;</span><br>serv.sin_family = AF_INET;<br>serv.sin_port = htons(<span class="hljs-number">8888</span>);<br>inet_pton(AF_INET, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, &amp;serv.sin_addr.s_addr);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%x]\n&quot;</span>, serv.sin_addr.s_addr);<br><span class="hljs-type">int</span> ret = connect(cfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv, <span class="hljs-keyword">sizeof</span>(serv));<br><span class="hljs-keyword">if</span>(ret&lt;<span class="hljs-number">0</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;connect error&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">256</span>];<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">//读标准输入数据</span><br><span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0x00</span>, <span class="hljs-keyword">sizeof</span>(buf));<br>n = read(STDIN_FILENO, buf, <span class="hljs-keyword">sizeof</span>(buf));<br><br><span class="hljs-comment">//发送数据</span><br>write(cfd, buf, n);<br><br><span class="hljs-comment">//读服务端发来的数据</span><br><span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0x00</span>, <span class="hljs-keyword">sizeof</span>(buf));<br>n = read(cfd, buf, <span class="hljs-keyword">sizeof</span>(buf));<br><span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read error or server closed, n==[%d]\n&quot;</span>, n);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n==[%d], buf==[%s]\n&quot;</span>, n, buf);<br>&#125;<br><br><span class="hljs-comment">//关闭套接字cfd</span><br>close(cfd);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>.</p>]]></content>
    
    
    <categories>
      
      <category>服务器编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>C语言</tag>
      
      <tag>Linux</tag>
      
      <tag>服务器编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux网络服务器编程03--socket使用流程、API以及数据的读写</title>
    <link href="/2023/06/30/ch20230630/"/>
    <url>/2023/06/30/ch20230630/</url>
    
    <content type="html"><![CDATA[<h3 id="1-socket的使用流程及相关API"><a href="#1-socket的使用流程及相关API" class="headerlink" title="1. socket的使用流程及相关API"></a>1. socket的使用流程及相关API</h3><ol><li>创建socket<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span>;<br></code></pre></td></tr></table></figure>函数调用成功返回一个socket文件描述符，失败则返回-1并设置errno。</li></ol><ul><li>domain: 使用的底层协议族，TCP&#x2F;IP协议族设置为PF_INET或PF_INET6, 对于UNIX本地协议族则设置为PF_UNIX;</li><li>type: 指定服务类型，主要有SOCK_STREAM流服务和SOCK_UGRAM数据报服务，对于TCP&#x2F;IP协议族而言，分别对应表示传输层使用TCP协议和UDP协议; 在Linux内核2.6.17之后，type参数可以接受服务类型与阻塞标志相与的值，SOCK_NONBLOCK和SOCK_CLOEXEC。前者表示将新创建的socket设置为非阻塞状态，后者表示在用fork调用创建子进程时在子进程中关闭该socket;</li><li>protocol: 表示在前两个参数构成的协议集合下，再选择一个具体的协议，该值通常已经被前两个参数决定为唯一值，一般设置为0，表示使用默认协议。</li></ul><ol start="2"><li><p>命名(绑定)socket<br>在服务器端，通常需要将socket绑定到一个固定的地址和端口，而客户端程序则使用操作系统自动分配的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* my_addr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br></code></pre></td></tr></table></figure></li><li><p>监听socket<br>服务器在绑定socket之后并不能马上接受客户端连接，需要创建一个监听队列，存放待处理的客户端连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> backlog)</span>;<br></code></pre></td></tr></table></figure></li></ol><ul><li>backlog: 提示内核监听队列的最大长度，监听队列长度如果超过backlog，则服务器将不再受理新的连接，客户端也将收到ECONNREFUSED连接被拒绝的错误信息。backlog参数的典型值为5.</li></ul><ol start="4"><li>接受socket连接<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr* addr, <span class="hljs-type">socklen_t</span>* addrlen)</span>;<br></code></pre></td></tr></table></figure></li></ol><ul><li>addrlen: 表示socket地址的长度</li></ul><ol start="5"><li>客户端发起连接<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* serv_addr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br></code></pre></td></tr></table></figure></li></ol><ul><li>serv_addr: 服务器的socket地址</li><li>addrlen: 地址的长度</li></ul><p>connect成功时返回0，表示成功与服务器建立连接，sockfd文件描述符则唯一标识该连接，客户端通过读写该文件描述符来与服务器进行通信。若连接失败，则返回-1并设置errno，常见的errno是ECONNREFUSED和ETIMEDOUT，前者表示目标地址和端口不存在，连接被拒绝；后者表示连接超时。</p><ol start="6"><li>关闭连接<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br></code></pre></td></tr></table></figure>close并非总是立即关闭一个连接，而是将文件描述符fd的引用计数减1，只有当引用计数为0时，该连接才是真正被关闭。在多进程中，一次fork系统调用默认会将父进程中的socket引用计数加1，因此必须在父进程和子进程中都对socket进行close才能将连接关闭。<br>若要立即终止连接，可以使用shutdown：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> howto)</span>;<br></code></pre></td></tr></table></figure></li></ol><ul><li>howto: 可选SHUT_RD, SHUT_WR, SHUT_RDWR. 分别表示关闭读端，关闭写端和同时关闭读写两端。</li><li>关闭读端时，不能再对socket进行读操作，且该socket接收缓冲区中的数据都将被丢弃；</li><li>关闭写端时，socket发送缓冲区中的数据会在真正关闭连接之前全部发送出去，不能再对其执行写操作，此时连接处于半关闭状态。</li></ul><h3 id="2-socket数据读写"><a href="#2-socket数据读写" class="headerlink" title="2. socket数据读写"></a>2. socket数据读写</h3><p>对于文件的读写操作read和write同样可以适用于socket，但socket编程提供了几个专门用于socket数据读写的系统调用，并增加了对数据读写的控制。</p><ol><li>TCP数据读写<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recv</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span>* buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags)</span>;<br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure></li></ol><ul><li>buf和flag分别指定缓冲区位置和大小，flags通常设置为0；</li></ul><p>recv成功时返回实际读取到的数据的长度，可能小于期望的长度len，因此可能需要多次调用recv才能读取到完整的数据。recv可能返回0，表示通信对方可能已经关闭连接，当recv出错时，返回-1并设置errno；</p><p>send成功时返回实际写入的数据的长度，失败则返回-1并设置errno；</p><ol start="2"><li>UDP数据读写<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvfrom</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span>* buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags, <span class="hljs-keyword">struct</span> sockaddr* src_addr, <span class="hljs-type">socklen_t</span>* addrlen)</span>;<br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendto</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* dest_addr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br></code></pre></td></tr></table></figure>由于UDP没有连接的概念，因此每次读写数据时都需要指定对方的地址，即src_addr和dest_addr;</li></ol><p>recvfrom和sendto也可以用于面向连接的数据读写，只需要将最后两个参数设置为NULL来忽略对方的地址即可，因此已经和对方建立了连接，因此已经知晓其地址。</p><ol start="3"><li>通用数据读写<br>socket编程接口还有一对通用的数据读写函数，都能够适用于TCP数据流服务和UDP数据报服务。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvmsg</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> msghdr* msg, <span class="hljs-type">int</span> flags)</span>;<br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendmsg</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> msghdr* msg, <span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure></li></ol><ul><li>msg: 是msghdr结构体类型的指针，其定义如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msghdr</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">void</span>* msg_name;         <span class="hljs-comment">// socket地址</span><br>    <span class="hljs-type">socklen_t</span> msg_namelen;  <span class="hljs-comment">// socket地址的长度</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span>* <span class="hljs-title">msg_iov</span>;</span>  <span class="hljs-comment">// 分散的内存块</span><br>    <span class="hljs-type">int</span> msg_iovlen;         <span class="hljs-comment">// 分散内存块的数量</span><br>    <span class="hljs-type">void</span>* msg_control;      <span class="hljs-comment">// 指向辅助数据的其实位置</span><br>    <span class="hljs-type">socklen_t</span> msg_controllen;   <span class="hljs-comment">// 辅助数据的大小</span><br>    <span class="hljs-type">int</span> msg_flags;          <span class="hljs-comment">// 复制函数中的flags参数，并在调用过程中更新</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>msg_name指向一个socket地址结构体变量，指定通信对方的socket地址，对于TCP该参数没有意义，设置为NULL；</li><li>msg_iov是iovec结构体类型的指针，其定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">void</span>* iov_base;         <span class="hljs-comment">// 内存起始地址</span><br>    <span class="hljs-type">size_t</span> iov_len;         <span class="hljs-comment">// 该内存块的长度</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p>msg_iovlen指定了iovec结构对象的个数。对于recvmsg而言，数据将被读取并存放在msg_iovlen块分散的内存中，这些内存的位置和长度则有msg_iov指向的数组指定，这称之为分散读；对于sendmsg而言，msg_iovlen块分散内存中的数据将被一并发送，称之为集中写。<br>msg_control和msg_controllen则用于辅助数据的传送。</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>[1] Linux高性能服务器编程 游双著.</p>]]></content>
    
    
    <categories>
      
      <category>服务器编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>C语言</tag>
      
      <tag>Linux</tag>
      
      <tag>服务器编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux网络服务器编程02--关于socket地址及API</title>
    <link href="/2023/06/29/ch20230629/"/>
    <url>/2023/06/29/ch20230629/</url>
    
    <content type="html"><![CDATA[<h3 id="1-关于socket地址"><a href="#1-关于socket地址" class="headerlink" title="1. 关于socket地址"></a>1. 关于socket地址</h3><h4 id="1-1-通用socket地址"><a href="#1-1-通用socket地址" class="headerlink" title="1.1 通用socket地址"></a>1.1 通用socket地址</h4><p>socket网络编程中表示socket地址的是结构体sockaddr；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/socket.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">sa_family_t</span> safamily;       <span class="hljs-comment">// 地址族类型sa_family_t</span><br>    <span class="hljs-type">char</span> sa_data[<span class="hljs-number">14</span>];           <span class="hljs-comment">// 用于存放socket地址值，仅14字节</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于14字节的sa_data无法容纳多数协议族的地址值，因此Linux定义了新的通用socket地址结构体；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/socket.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">sa_family_t</span> sa_family;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> __ss_align;<br>    <span class="hljs-type">char</span> __ss_padding[<span class="hljs-number">128</span>-<span class="hljs-keyword">sizeof</span>(__ss_align)];<br>&#125;<br></code></pre></td></tr></table></figure><p>该结构体不仅提供了足够大的空间用于存放地址值，并且由于__ss_align的作用，其是内存对齐的。</p><h4 id="1-2-专用socket地址"><a href="#1-2-专用socket地址" class="headerlink" title="1.2 专用socket地址"></a>1.2 专用socket地址</h4><p>由于通用的socket地址结构体不好用，在设置和获取IP地址和端口号时较为繁琐，因此Linux为各个协议族协议提供了专门的socket结构体。<br>Unix本地域协议族通常使用如下专用结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/un.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">sa_family_t</span> sin_family;     <span class="hljs-comment">// 地址协议族：AF_UNIX</span><br>    <span class="hljs-type">char</span> sun_path[<span class="hljs-number">108</span>];         <span class="hljs-comment">// 文件路径名</span><br>&#125;<br></code></pre></td></tr></table></figure><p>TCP&#x2F;IP协议族则有sockaddr_in 和 sockaddr_in6 两个专用socket地址结构体，分别用于IPv4和IPv6。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">sa_family_t</span> sa_family;      <span class="hljs-comment">// 地址协议族：AF_INET</span><br>    <span class="hljs-type">u_int16_t</span> sin_port;         <span class="hljs-comment">// 端口号，需要用网络字节序表示</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span>    <span class="hljs-comment">// IPv4结构体</span><br>&#125;;<br><br><span class="hljs-comment">// IPv4结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">u_int32_t</span> s_addr;           <span class="hljs-comment">// IPv4地址，需要用网络字节序表示</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in6</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">sa_family_t</span> sin6_family;    <span class="hljs-comment">// 地址协议族：AF_INET6</span><br>    <span class="hljs-type">u_int16_t</span> sin6_port;        <span class="hljs-comment">// 端口号，需要用网络字节序表示</span><br>    <span class="hljs-type">u_int32_t</span> sin6_flowinfo;    <span class="hljs-comment">// 流信息，应设置为0</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span> <span class="hljs-title">sin6_addr</span>;</span>  <span class="hljs-comment">// IPv6地址结构体</span><br>    <span class="hljs-type">u_int32_t</span> sin6_scope_id;    <span class="hljs-comment">// scope ID, 暂时处于实验阶段，不使用</span><br>&#125;;<br><br><span class="hljs-comment">// IPv6地址结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> sa_addr[<span class="hljs-number">16</span>];  <span class="hljs-comment">// IPv6地址，需要用网络字节序表示</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-IP地址转换"><a href="#2-IP地址转换" class="headerlink" title="2. IP地址转换"></a>2. IP地址转换</h3><p>下列3个函数能够用于点分十进制字符串表示的IPv4地址与用网络字节序整数表示的IPv4地址之间的转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-comment">// 将点分十进制字符串的地址转换为网络字节序整数地址, 失败时返回INADDR_NONE</span><br><span class="hljs-type">in_addr_t</span> <span class="hljs-title function_">inet_addr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* strptr)</span>;<br><br><span class="hljs-comment">// 作用与inet_addr一样，但会将转换的结果存储于inp所指向的地址结构体中，成功返回1，失败返回0；</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">inet_aton</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* cp, <span class="hljs-keyword">struct</span> in_addr* inp)</span>;<br><br><span class="hljs-comment">// 将网络字节序表示的地址转为点分十进制字符串</span><br><span class="hljs-type">char</span>* <span class="hljs-title function_">inet_ntoa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> in_addr in)</span>;<br></code></pre></td></tr></table></figure><p>NOTE: 需要注意的是，inet_ntoa内部是使用一个静态变量存储转换的结果，函数的返回值则指向该静态内存，因此inet_ntoa是不可重入的，即当再次调用该函数时，静态变量内存中的结果将被新的覆盖。<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">addr1</span> =</span> &#123;<span class="hljs-number">0x8417a8c0</span>&#125;;    <span class="hljs-comment">// 192.168.23.132 反转后的16进制</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">addr2</span> =</span> &#123;<span class="hljs-number">0xb90d190a</span>&#125;;    <span class="hljs-comment">// 10.25.13.185 反转后的16进制</span><br><br>    <span class="hljs-type">char</span>* value1 = inet_ntoa(addr1);<br>    <span class="hljs-type">char</span>* value2 = inet_ntoa(addr2);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr 1: %s\n&quot;</span>, value1);         <span class="hljs-comment">// addr 1: 10.25.13.185</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr 2: %s\n&quot;</span>, value2);         <span class="hljs-comment">// addr 2: 10.25.13.185</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下更新的函数也能实现与前述3个函数一样的功能，并且能够同时适用于IPv4和IPv6地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-comment">// 将使用点分十进制字符串（IPv4）或十六进制字符串（IPv6）表示的IP地址src 转换为网络字节序表示的IP地址，并将转换结果存储于dst所指向的内存中，其中，af指定地址族，AF_INET或者AF_INET6。函数成功返回1，失败返回0并设置errno。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">inet_pton</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* src, <span class="hljs-type">void</span>* dst)</span>;<br><br><span class="hljs-comment">// 执行相反的转换，参数类似，其中，cnt指定目标存储单元的大小。函数成功返回目标存储单元的地址，失败则返回NULL并设置errno</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">inet_ntop</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* src, <span class="hljs-type">char</span>* dst, <span class="hljs-type">socklen_t</span> cnt)</span>;<br></code></pre></td></tr></table></figure><p>其中下列宏能够为cnt指定大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INET_ADDRSTRLEN 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INET6_ADDRSTRLEN 46</span><br></code></pre></td></tr></table></figure><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>[1] Linux高性能服务器编程 游双著.</p>]]></content>
    
    
    <categories>
      
      <category>服务器编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>C语言</tag>
      
      <tag>Linux</tag>
      
      <tag>服务器编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux网络服务器编程01--关于主机字节序和网络字节序</title>
    <link href="/2023/04/13/ch20230413/"/>
    <url>/2023/04/13/ch20230413/</url>
    
    <content type="html"><![CDATA[<h3 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h3><p>由于现代CPU的累加器一次能够装载至少4字节(在32位机环境下)，即一个整数。该4字节在内存中的排列顺序便会影响到其被累加器装载时所生成的整数值，这就是字节序问题。字节序分为大端字节序（big endian）和小端字节序（little endian）。</p><ul><li>大端字节序：<br>  一个整数的高位字节(23-31 bit)存储在内存的低地址处，而低位字节(0-7 bit)存储在内存的高地址处；</li><li>小端字节序：<br>  指整数的高位字节存储在内存的高地址处，而低位字节存储在内存的低地址处。<br>由于现代PC大多采用小端字节序，因此小端字节序也被成为“主机字节序”。当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端不进行转换的话必然会导致错误解释。因此，解决问题的方法是：发送端总是将要发送的数据转化成大端字节序数据后再进行发送，而接收端由于知道发送方总是采用大端字节序，所以接收端便可以根据自身所采用的字节序来决定是否对收到的数据进行转换。因此，大端字节序也被称为“网络字节序”，其为所有接收数据的主机提供了一个正确解析收到的格式化数据的保证。<br>NOTE：即便是同一台机器上的两个进程之间（比如一个是C语言程序，另一个是Java语言程序）通信，也需要考虑字节序问题，例如Java虚拟机便是采用大端字节序。</li></ul><h3 id="2-API函数"><a href="#2-API函数" class="headerlink" title="2. API函数"></a>2. API函数</h3><p>Linux环境中提供了如下4个函数来完成主机字节序和网络字节序之间的转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">htonl</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> hostlong)</span>;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-title function_">htons</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> hostshort)</span>;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ntohl</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> netlong)</span>;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ntohs</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> netshort)</span>;<br></code></pre></td></tr></table></figure><p>上述API函数含义很明确，例如 htonl 即表示“host to network long”，即将长整型(32 bit)的主机字节序转换成网络字节序数据。<br>在4个函数中，长整型函数通常用来转换IP地址，而短整型则用来转换端口号。当然不限于此，任何格式化数据通过网络传输时，都应该使用这些函数来转换字节序。</p><h3 id="3-判断机器字节序"><a href="#3-判断机器字节序" class="headerlink" title="3. 判断机器字节序"></a>3. 判断机器字节序</h3><p>如下代码可以用来检查所使用机器的字节序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">byteorder</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">union</span>&#123;</span><br><span class="hljs-type">short</span> value;<br><span class="hljs-type">char</span> union_bytes[<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">short</span>)];<br>&#125;test;<br><br>test.value = <span class="hljs-number">0x0102</span>;<br><br><span class="hljs-keyword">if</span>((test.union_bytes[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &amp;&amp; (test.union_bytes[<span class="hljs-number">1</span>] == <span class="hljs-number">2</span>))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Big endian!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((test.union_bytes[<span class="hljs-number">0</span>] == <span class="hljs-number">2</span>) &amp;&amp; (test.union_bytes[<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Little endian!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unkown...\n&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>byteorder();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>服务器编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>C语言</tag>
      
      <tag>Linux</tag>
      
      <tag>服务器编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个利用C11实现的简单计算器应用</title>
    <link href="/2023/04/08/ch20230408/"/>
    <url>/2023/04/08/ch20230408/</url>
    
    <content type="html"><![CDATA[<h3 id="1-利用C11实现的简单计算器应用"><a href="#1-利用C11实现的简单计算器应用" class="headerlink" title="1. 利用C11实现的简单计算器应用"></a>1. 利用C11实现的简单计算器应用</h3><p>这里是一个使用C11实现的简单计算器应用程序，测试发现在Linux环境下可以正常运行，Windows下则存在问题。<br>在Linux中，使用<code>gcc main.c -o simpleCalcultor -std=gnu11 -lm</code>即可进行编译，其中，-std&#x3D;gnu11 表示使用C11，-lm表示链接数学库，否则编译会出现异常。<br>运行&#96;&#96; .&#x2F;simplecalculator 1+2&#96;&#96;&#96;.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdalign.h&gt;</span></span><br><br><span class="hljs-comment">// 使用简约的var作为对象类型的自动推导</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> var __auto_type</span><br><br><span class="hljs-comment">// 指定输入表达式的最大长度为2047字节，超出部分将会被截断</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ARGUMENT_LENGTH 2047</span><br><br><span class="hljs-comment">// 用于标记解析符号时的当前状态</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PARSE_PHASE_STATUS</span></span><br><span class="hljs-class">&#123;</span><br>    PARSE_PHASE_STATUS_LEFT_OPERAND = <span class="hljs-number">0</span>,<br>    PARSE_PHASE_STATUS_RIGHT_OPERAND,<br>    PARSE_PHASE_STATUS_LEFT_PARENTHESIS,<br>    PARSE_PHASE_STATUS_NEED_OPERATOR = <span class="hljs-number">4</span>,<br>    PARSE_PHASE_STATUS_HAS_NEG = <span class="hljs-number">8</span><br>&#125;;<br><br><span class="hljs-comment">// 当前算术计算优先级</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">OPERATOR_PRIORITY</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// 加减法优先级</span><br>    OPERATOR_PRIORITY_ADD,<br><br>    <span class="hljs-comment">// 乘除以及求模优先级</span><br>    OPERATOR_PRIORITY_MUL,<br><br>    <span class="hljs-comment">// 幂运算优先级</span><br>    OPERATOR_PRIORITY_POW<br>&#125;;<br><br><span class="hljs-comment">// 判断当前字符是否属于数字</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">IsDigital</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">/* 判断当前是否为数字常量</span><br><span class="hljs-comment">@return 如果是数字常量，则返回该常量的字符个数，否则返回0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">IsMathConstant</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* cursor)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (cursor[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;p&#x27;</span> &amp;&amp; cursor[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;i&#x27;</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        由于本程序还支持exp函数用于计算e的指数幂，</span><br><span class="hljs-comment">        所以如果后面e后面包含了一个x，那么这个e就不会是数字常量</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-keyword">if</span> (cursor[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;e&#x27;</span> &amp;&amp; cursor[<span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;x&#x27;</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 判断当前字符是否可能为函数</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">IsMathFunction</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> ch &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// 对数字进行解析</span><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">ParseDigital</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* cursor, <span class="hljs-type">int</span>* pRetLength)</span><br>&#123;<br>    <span class="hljs-comment">// 先判断当前是否为数字常量</span><br>    var length = IsMathConstant(cursor);<br>    <span class="hljs-keyword">if</span> (length &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        *pRetLength = length;<br>        <span class="hljs-keyword">return</span> (cursor[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;p&#x27;</span>) ? M_PI : M_E;<br>    &#125;<br><br>    <span class="hljs-type">char</span> value[MAX_ARGUMENT_LENGTH + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-type">char</span> ch;<br>    var index = <span class="hljs-number">0</span>;<br>    var hasDot = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        ch = cursor[index];<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;.&#x27;</span>)<br>        &#123;<br>            <span class="hljs-comment">// 如果之前已经出现了小数点，那么这里就中断解析</span><br>            <span class="hljs-keyword">if</span> (hasDot)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                hasDot = <span class="hljs-literal">true</span>;<br>                value[index] = ch;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!IsDigital(ch))<br>        &#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 在其他情况下，如果不是数字，则立即中断解析</span><br>        &#125;<br><br>        value[index++] = ch;<br>    &#125; <span class="hljs-keyword">while</span> (ch != <span class="hljs-string">&#x27;\0&#x27;</span>);<br><br>    value[index] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    *pRetLength = index;<br><br>    <span class="hljs-comment">// atof函数是将一个字符数组中的内容转换为一个double类型的浮点数值</span><br>    <span class="hljs-comment">// 该函数在&lt;stdlib.h&gt;</span><br>    <span class="hljs-keyword">return</span> atof(value);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">AddOp</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">MinusOp</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a - b;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">MulOp</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a * b;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">DivOp</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a / b;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">ModOp</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span><br>&#123;<br>    <span class="hljs-comment">// 求模操作时，操作数必须为整数，因此这里将a和b都转换为带符号的64位整数类型</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int64_t</span>)a % (<span class="hljs-type">int64_t</span>)b;<br>&#125;<br><br><span class="hljs-comment">// 定义一个操作函数列表，方便快速定位当前操作符所对应的操作函数</span><br><span class="hljs-type">static</span> <span class="hljs-title function_">double</span> <span class="hljs-params">(* <span class="hljs-type">const</span> opFuncTables[])</span><span class="hljs-params">(<span class="hljs-type">double</span>, <span class="hljs-type">double</span>)</span> = &#123;<br>    <span class="hljs-comment">/*     为了进一步节省全局存储空间，这里将根据ASCII码表找出最小的字符值，将该值作为0，后续的都减去该值。</span><br><span class="hljs-comment">        通过ASCII表可以知道，值最小的符号是%，它的值为0x25。然后可以用指定索引的初始化器对opFuncTables进行初始化。 */</span><br>    [<span class="hljs-string">&#x27;%&#x27;</span> - <span class="hljs-string">&#x27;%&#x27;</span>] = &amp;ModOp,<br>    [<span class="hljs-string">&#x27;*&#x27;</span> - <span class="hljs-string">&#x27;%&#x27;</span>] = &amp;MulOp,<br>    [<span class="hljs-string">&#x27;+&#x27;</span> - <span class="hljs-string">&#x27;%&#x27;</span>] = &amp;AddOp,<br>    [<span class="hljs-string">&#x27;-&#x27;</span> - <span class="hljs-string">&#x27;%&#x27;</span>] = &amp;MinusOp,<br>    [<span class="hljs-string">&#x27;/&#x27;</span> - <span class="hljs-string">&#x27;%&#x27;</span>] = &amp;DivOp,<br>    [<span class="hljs-string">&#x27;^&#x27;</span> - <span class="hljs-string">&#x27;%&#x27;</span>] = &amp;<span class="hljs-built_in">pow</span> &#125;;<br><br><span class="hljs-comment">// 判定是否为有效操作符</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">IsOperator</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (ch &gt;= <span class="hljs-string">&#x27;%&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;/&#x27;</span>) || ch == <span class="hljs-string">&#x27;^&#x27;</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">radian</span><span class="hljs-params">(<span class="hljs-type">double</span> degree)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> degree * M_PI / <span class="hljs-number">180.0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">degree</span><span class="hljs-params">(<span class="hljs-type">double</span> radian)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> radian * <span class="hljs-number">180.0</span> / M_PI;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">cot</span><span class="hljs-params">(<span class="hljs-type">double</span> radian)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">tan</span>(M_PI * <span class="hljs-number">0.5</span> - radian);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">recp</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / x;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> name;<br>    <span class="hljs-type">double</span> (*pFunc)(<span class="hljs-type">double</span>);<br>&#125; mathFuncList[] = &#123;<br>    &#123;<span class="hljs-string">&#x27;\0nis&#x27;</span>, &amp;<span class="hljs-built_in">sin</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;\0soc&#x27;</span>, &amp;<span class="hljs-built_in">cos</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;\0nat&#x27;</span>, &amp;<span class="hljs-built_in">tan</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;\0toc&#x27;</span>, &amp;cot&#125;,<br>    &#123;<span class="hljs-string">&#x27;hnis&#x27;</span>, &amp;<span class="hljs-built_in">sinh</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;hsoc&#x27;</span>, &amp;<span class="hljs-built_in">cosh</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;hnat&#x27;</span>, &amp;<span class="hljs-built_in">tanh</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;nisa&#x27;</span>, &amp;<span class="hljs-built_in">asin</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;soca&#x27;</span>, &amp;<span class="hljs-built_in">acos</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;nata&#x27;</span>, &amp;<span class="hljs-built_in">atan</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;hnsa&#x27;</span>, &amp;asinh&#125;,<br>    &#123;<span class="hljs-string">&#x27;hsca&#x27;</span>, &amp;acosh&#125;,<br>    &#123;<span class="hljs-string">&#x27;\0gol&#x27;</span>, &amp;log2&#125;,<br>    &#123;<span class="hljs-string">&#x27;\0\0gl&#x27;</span>, &amp;<span class="hljs-built_in">log10</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;\0\0nl&#x27;</span>, &amp;<span class="hljs-built_in">log</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;trqs&#x27;</span>, &amp;<span class="hljs-built_in">sqrt</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;trbc&#x27;</span>, cbrt&#125;,<br>    &#123;<span class="hljs-string">&#x27;pcer&#x27;</span>, &amp;recp&#125;,<br>    &#123;<span class="hljs-string">&#x27;\0dar&#x27;</span>, &amp;radian&#125;,<br>    &#123;<span class="hljs-string">&#x27;\0ged&#x27;</span>, &amp;degree&#125;,<br>    &#123;<span class="hljs-string">&#x27;\0pxe&#x27;</span>, &amp;<span class="hljs-built_in">exp</span>&#125; &#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-title function_">double</span> <span class="hljs-params">(*ParseMathFunction(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* cursor, <span class="hljs-type">int</span>* pLength))</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 这里buffer至少要求4字节对齐，因此后面会对前4个字节内容进行同时访问</span><br>    <span class="hljs-type">char</span> <span class="hljs-title function_">alignas</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span> buffer[8] = &#123; <span class="hljs-string">&#x27;\0&#x27;</span> &#125;;<br>    var index = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 由于这里规定的数学符号最多占用4个字节，所以需要使用一个计数器来防止访问越界</span><br>    <span class="hljs-keyword">for</span> (var count = <span class="hljs-number">0</span>; count &lt; <span class="hljs-number">4</span>; count++, index++)<br>    &#123;<br>        var ch = cursor[index];<br>        <span class="hljs-keyword">if</span> (!IsMathFunction(ch))<br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        buffer[index] = ch;<br>    &#125;<br><br>    buffer[index] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    <span class="hljs-comment">// 同时取出刚才所存放的4个字节内容，方便比较</span><br>    var value = *(<span class="hljs-type">int</span>*)buffer;<br><br>    <span class="hljs-comment">// 查找函数表中是否含有该函数名称</span><br>    <span class="hljs-type">const</span> var length = <span class="hljs-keyword">sizeof</span>(mathFuncList) / <span class="hljs-keyword">sizeof</span>(mathFuncList[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">for</span> (typeof(length + <span class="hljs-number">0</span>) i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (mathFuncList[i].name == value)<br>        &#123;<br>            *pLength = index;<br>            <span class="hljs-keyword">return</span> mathFuncList[i].pFunc;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">/* 解析当前的算术表达式</span><br><span class="hljs-comment">@param ppCursor 指向当前算术表达式字符串的地址,它既是输入又是输出。</span><br><span class="hljs-comment">当当前算术表达式作为括号进行计算时，需要将右括号的位置输出到实参。</span><br><span class="hljs-comment">@param leftOperand 当前左操作数的值</span><br><span class="hljs-comment">@param status 当前计算状态</span><br><span class="hljs-comment">@param priority 当前计算的算术优先级</span><br><span class="hljs-comment">@param pStatus 输出解析状态</span><br><span class="hljs-comment">@return 输出计算表达式的结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">ParseArithmeticExpression</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>** ppCursor,</span><br><span class="hljs-params">    <span class="hljs-type">double</span> leftOperand,</span><br><span class="hljs-params">    <span class="hljs-keyword">enum</span> PARSE_PHASE_STATUS status,</span><br><span class="hljs-params">    <span class="hljs-keyword">enum</span> OPERATOR_PRIORITY priority,</span><br><span class="hljs-params">    <span class="hljs-type">bool</span>* pStatus)</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* cursor = *ppCursor;<br>    var rightOperand = <span class="hljs-number">0.0</span>;<br>    var length = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 指向操作符函数的指针</span><br>    <span class="hljs-type">double</span> (*pOpFunc)(<span class="hljs-type">double</span>, <span class="hljs-type">double</span>) = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 指向数学函数的指针</span><br>    <span class="hljs-type">double</span> (*pMathFunc)(<span class="hljs-type">double</span>) = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-type">bool</span> isSuccessful = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-type">char</span> ch;<br><br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        ch = *cursor;<br><br>        <span class="hljs-comment">// 先判定当前字符是否属于数字或数字常量</span><br>        <span class="hljs-keyword">if</span> (IsDigital(ch) || IsMathConstant(cursor) &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">double</span> value = ParseDigital(cursor, &amp;length);<br>            cursor += length;<br><br>            <span class="hljs-keyword">if</span> ((status &amp; PARSE_PHASE_STATUS_RIGHT_OPERAND) == PARSE_PHASE_STATUS_LEFT_OPERAND)<br>            &#123;<br>                leftOperand = value;<br>                <span class="hljs-comment">// 如果具有负数符号，则将左操作数做取反数操作</span><br>                <span class="hljs-keyword">if</span> ((status &amp; PARSE_PHASE_STATUS_HAS_NEG) != <span class="hljs-number">0</span>)<br>                &#123;<br>                    leftOperand = -leftOperand;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">// 对于当前为右操作数的情况，根据操作符计算优先级，需要进一步判定后面的操作优先级是否大于前面的；</span><br>                    <span class="hljs-comment">// 如果大于前面的，则需要做递归计算</span><br>                    rightOperand = value;<br>                    <span class="hljs-comment">// 如果具有负数符号，则将左操作数做取反数操作</span><br>                    <span class="hljs-keyword">if</span> ((status &amp; PARSE_PHASE_STATUS_HAS_NEG) != <span class="hljs-number">0</span>)<br>                    &#123;<br>                        rightOperand = -rightOperand;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 清除负数标志</span><br>                status &amp;= ~PARSE_PHASE_STATUS_HAS_NEG;<br><br>                <span class="hljs-comment">// 添加后续需要算术操作符的状态标志</span><br>                status |= PARSE_PHASE_STATUS_NEED_OPERATOR;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (IsMathFunction(ch))<br>            &#123;<br>                pMathFunc = ParseMathFunction(cursor, &amp;length);<br>                <span class="hljs-keyword">if</span> (pMathFunc == <span class="hljs-literal">NULL</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 如果数学函数为空，说明解析失败，立即中断解析</span><br>                    isSuccessful = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                cursor += length;<br>                <span class="hljs-keyword">if</span> (*cursor != <span class="hljs-string">&#x27;(&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 如果函数后面没有跟左括号(, 那也不是一个合法的表达式，立即中断解析</span><br>                    isSuccessful = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (IsOperator(ch))<br>            &#123;<br>                <span class="hljs-comment">// 这里包含了常用的算术操作符以及左右圆括号。因此在这个分支中同时对这两类符号进行解析判断</span><br>                <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;(&#x27;</span>)<br>                &#123;<br>                    cursor++;<br><br>                    <span class="hljs-type">double</span> value = ParseArithmeticExpression(&amp;cursor, <span class="hljs-number">0.0</span>,<br>                        PARSE_PHASE_STATUS_LEFT_OPERAND | PARSE_PHASE_STATUS_LEFT_PARENTHESIS,<br>                        OPERATOR_PRIORITY_ADD, &amp;isSuccessful);<br><br>                    <span class="hljs-comment">// 如果当前游标所指向的字符不是右圆括号), 说明没有匹配到合适的右圆括号，中断解析</span><br>                    <span class="hljs-keyword">if</span> (!isSuccessful || *cursor != <span class="hljs-string">&#x27;)&#x27;</span>)<br>                    &#123;<br>                        isSuccessful = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> ((status &amp; PARSE_PHASE_STATUS_RIGHT_OPERAND) == <span class="hljs-number">0</span>)<br>                    &#123;<br>                        <span class="hljs-comment">// 如果当前状态为左操作数</span><br>                        <span class="hljs-keyword">if</span> (pMathFunc != <span class="hljs-literal">NULL</span>)<br>                        &#123;<br>                            leftOperand = pMathFunc(value);<br>                            pMathFunc = <span class="hljs-literal">NULL</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span><br>                        &#123;<br>                            leftOperand = value;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        <span class="hljs-comment">// 如果当前状态为右操作数</span><br>                        <span class="hljs-keyword">if</span> (pMathFunc != <span class="hljs-literal">NULL</span>)<br>                        &#123;<br>                            rightOperand = pMathFunc(value);<br>                            pMathFunc = <span class="hljs-literal">NULL</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span><br>                        &#123;<br>                            rightOperand = value;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">// 清楚当前左括号状态</span><br>                    status &amp;= ~PARSE_PHASE_STATUS_LEFT_PARENTHESIS;<br><br>                    <span class="hljs-comment">// 添加后续需要算术操作符的状态标志</span><br>                    status |= PARSE_PHASE_STATUS_NEED_OPERATOR;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;)&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 将当前游标位置输出给实参</span><br>                    *ppCursor = cursor;<br>                    <span class="hljs-keyword">return</span> (pOpFunc != <span class="hljs-literal">NULL</span>) ? pOpFunc(leftOperand, rightOperand) : leftOperand;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> ((status &amp; PARSE_PHASE_STATUS_NEED_OPERATOR) == <span class="hljs-number">0</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>)<br>                        &#123;<br>                            <span class="hljs-comment">// 如果当前不需要操作符，则将减号视为负数符号</span><br>                            <span class="hljs-comment">// 作为负数符号，后面必须紧跟一个操作数，否则也是无效的</span><br>                            <span class="hljs-keyword">if</span> (IsDigital(cursor[<span class="hljs-number">1</span>]) || IsMathConstant(&amp;cursor[<span class="hljs-number">1</span>]) &gt; <span class="hljs-number">0</span>)<br>                            &#123;<br>                                status |= PARSE_PHASE_STATUS_HAS_NEG;<br>                            &#125;<br>                            <span class="hljs-keyword">else</span><br>                            &#123;<br>                                isSuccessful = <span class="hljs-literal">false</span>;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span><br>                        &#123;<br>                            <span class="hljs-comment">// 对于其他情况，如果当前状态不需要操作符，那么表达式是非法的，立即中断解析</span><br>                            isSuccessful = <span class="hljs-literal">false</span>;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        var tmpFunc = opFuncTables[ch - <span class="hljs-string">&#x27;%&#x27;</span>];<br>                        <span class="hljs-keyword">if</span> (tmpFunc == <span class="hljs-literal">NULL</span>)<br>                        &#123;<br>                            <span class="hljs-comment">// 如果没有找到对应的操作符函数，说明当前输入的字符是非法的，直接中断解析</span><br>                            isSuccessful = <span class="hljs-literal">false</span>;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        <span class="hljs-comment">// 判断当前操作符的计算优先级</span><br>                        var pry = OPERATOR_PRIORITY_ADD;<br>                        <span class="hljs-keyword">if</span> (tmpFunc == ModOp || tmpFunc == MulOp || tmpFunc == DivOp)<br>                        &#123;<br>                            pry = OPERATOR_PRIORITY_MUL;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmpFunc == <span class="hljs-built_in">pow</span>)<br>                        &#123;<br>                            pry = OPERATOR_PRIORITY_POW;<br>                        &#125;<br><br>                        <span class="hljs-keyword">if</span> (pOpFunc == <span class="hljs-literal">NULL</span>)<br>                        &#123;<br>                            pOpFunc = tmpFunc;<br>                        &#125;<br><br>                        <span class="hljs-keyword">if</span> ((status &amp; PARSE_PHASE_STATUS_RIGHT_OPERAND) == <span class="hljs-number">0</span>)<br>                        &#123;<br>                            <span class="hljs-comment">// 当前操作符解析成功，后续将需要该操作的右操作数</span><br>                            status |= PARSE_PHASE_STATUS_RIGHT_OPERAND;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span><br>                        &#123;<br>                            <span class="hljs-comment">// 如果之前优先级不小于当前操作符的优先级，那么立即做归约</span><br>                            <span class="hljs-keyword">if</span> (priority &gt;= pry)<br>                            &#123;<br>                                leftOperand = pOpFunc(leftOperand, rightOperand);<br>                                rightOperand = <span class="hljs-number">0.0</span>;<br>                                <span class="hljs-comment">// 随后更新当前操作函数以及计算优先级</span><br>                                pOpFunc = tmpFunc;<br>                            &#125;<br>                            <span class="hljs-keyword">else</span><br>                            &#123;<br>                                <span class="hljs-comment">// 如果当前碰到了比之前优先级更高的操作符，则采用递归的方式进行计算</span><br>                                <span class="hljs-keyword">if</span> (pOpFunc == MinusOp)<br>                                &#123;<br>                                    <span class="hljs-comment">// 如果之前的计算是减法，根据减法不适用于结合率的性质，这里将其视为一个加法，并将右操作数取负值</span><br>                                    pOpFunc = AddOp;<br>                                    rightOperand = -rightOperand;<br>                                &#125;<br>                                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pOpFunc == DivOp)<br>                                &#123;<br>                                    <span class="hljs-comment">// 如果之前的计算是除法，根据除法不适用于结合律的性质，这里将其视为一个乘法，并将右操作数取其倒数</span><br>                                    pOpFunc = MulOp;<br>                                    rightOperand = <span class="hljs-number">1.0</span> / rightOperand;<br>                                &#125;<br><br>                                <span class="hljs-comment">// 递归做高优先级的运算操作</span><br>                                var value = ParseArithmeticExpression(<br>                                    &amp;cursor,<br>                                    rightOperand,<br>                                    PARSE_PHASE_STATUS_LEFT_OPERAND | PARSE_PHASE_STATUS_NEED_OPERATOR,<br>                                    pry,<br>                                    pStatus);<br><br>                                <span class="hljs-comment">// 由于可能会碰到在括号操作中的高优先级运算的归约，比如考虑这个表达式：(1+2*3), 这里2*3)会在同一个调用级中，</span><br>                                <span class="hljs-comment">// 所以)的输出无法影响到先前的(，所以这里也要将当前有标位置进行输出，返回给上一级的调用</span><br>                                *ppCursor = cursor;<br>                                <span class="hljs-keyword">return</span> pOpFunc(leftOperand, value);<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-comment">// 更新当前计算优先级</span><br>                        priority = pry;<br>                    &#125;<br>                    <span class="hljs-comment">// 清除需要操作符标志</span><br>                    status &amp;= ~PARSE_PHASE_STATUS_NEED_OPERATOR;<br>                &#125;<br>                <span class="hljs-comment">// 对于所有操作符情况，最后都让游标往前走一格</span><br>                cursor++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// 如果遇到其他字符，如果不是字符串结束符则宣告解析失败</span><br>                <span class="hljs-keyword">if</span> (ch != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>                &#123;<br>                    isSuccessful = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (ch != <span class="hljs-string">&#x27;\0&#x27;</span>);<br><br>    <span class="hljs-comment">// 如果解析失败，则后续出结果时不做任何相关计算</span><br>    <span class="hljs-keyword">if</span> (!isSuccessful)<br>    &#123;<br>        pOpFunc = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pStatus != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        *pStatus = isSuccessful;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (pOpFunc == <span class="hljs-literal">NULL</span>) ? leftOperand : pOpFunc(leftOperand, rightOperand);<br>&#125;<br><br><span class="hljs-comment">/* 计算输入的表达式</span><br><span class="hljs-comment">@param expr 输入的算术表达式字符串</span><br><span class="hljs-comment">@param result 以字符串形式输出结果，这里设置了实参至少需要提供的缓存长度</span><br><span class="hljs-comment">@return 如果表达式解析成功，返回true，否则返回false</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">CalculateArithmeticExpression</span><span class="hljs-params">(<span class="hljs-type">char</span> expr[], <span class="hljs-type">char</span> result[<span class="hljs-type">static</span> <span class="hljs-number">32</span>])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (expr[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 对输入的字符串做一些过滤，使得当中出现的一些符号能够对本程序进行适配</span><br>    var length = (<span class="hljs-type">int</span>)<span class="hljs-built_in">strlen</span>(expr);<br><br>    <span class="hljs-comment">// 由于一些命令控制台不支持带有圆括号()的表达式，但支持方括号[]表达式；这里将输入中的方括号[]再替换回();</span><br>    <span class="hljs-comment">// 此外，将出现的所有大写字母替换为小写字母</span><br>    <span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>    &#123;<br>        var ch = expr[i];<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;[&#x27;</span>)<br>        &#123;<br>            expr[i] = <span class="hljs-string">&#x27;(&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;]&#x27;</span>)<br>        &#123;<br>            expr[i] = <span class="hljs-string">&#x27;)&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;$&#x27;</span>)<br>        &#123;<br>            expr[i] == <span class="hljs-string">&#x27;^&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)<br>        &#123;<br>            <span class="hljs-comment">// 由于ASCII码的巧妙设计，大写字母与小写字母正好相差0x20, 这里只需通过加上0x20值就能方便地将大写字母转换为小写字母</span><br>            expr[i] += <span class="hljs-number">0x20</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> ret = <span class="hljs-literal">false</span>;<br><br>    var value = ParseArithmeticExpression(<br>        (<span class="hljs-type">const</span> <span class="hljs-type">char</span>**)&amp;expr,<br>        <span class="hljs-number">0.0</span>,<br>        PARSE_PHASE_STATUS_LEFT_OPERAND,<br>        OPERATOR_PRIORITY_ADD,<br>        &amp;ret);<br><br>    <span class="hljs-keyword">if</span> (!ret)<br>    &#123;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-comment">// 将结果显示为小数点后面跟8位尾数</span><br>    <span class="hljs-built_in">sprintf</span>(result, <span class="hljs-string">&quot;%.8f&quot;</span>, value);<br><br>    <span class="hljs-comment">// 将多余的.00000这种字样给过滤掉，使得结果输出更好看些</span><br>    length = (<span class="hljs-type">int</span>)<span class="hljs-built_in">strlen</span>(result);<br>    var dotIndex = <span class="hljs-number">-1</span>;<br>    var hasE = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (result[i] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>        &#123;<br>            dotIndex = i;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result[i] == <span class="hljs-string">&#x27;e&#x27;</span>)<br>        &#123;<br>            hasE = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 这里只有再仅存在小数点的情况下进行过滤</span><br>    <span class="hljs-keyword">if</span> (dotIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; !hasE)<br>    &#123;<br>        var index = length;<br><br>        <span class="hljs-keyword">while</span> (--index &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (result[index] != <span class="hljs-string">&#x27;0&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            result[index] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果dotIndex后面没有具体数字，则将小数点也过滤掉</span><br>        <span class="hljs-keyword">if</span> (result[dotIndex + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        &#123;<br>            result[dotIndex] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>    <span class="hljs-comment">// argc用来存放参数个数，在Windows以及各类Unix中，参数以空格进行分隔；</span><br>    <span class="hljs-comment">// 因此，在使用该程序时，计算表达式中不应该含有空符(包括空格和制表符)。</span><br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No expression to calculate!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    var length = <span class="hljs-built_in">strlen</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No expression to calculate!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 对参数表达式长度做截断，取由宏指定的长度</span><br>    <span class="hljs-keyword">if</span> (length &gt; MAX_ARGUMENT_LENGTH)<br>    &#123;<br>        length = MAX_ARGUMENT_LENGTH;<br>    &#125;<br><br>    <span class="hljs-comment">// 准备一个字符串缓存，将通过程序参数传递进来的字符串表达式拷贝到当前程序的栈上，便于后续解析操作</span><br>    <span class="hljs-type">char</span> argBuffer[MAX_ARGUMENT_LENGTH + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 使用strncpy也使得在做字符串拷贝时确保长度不超过指定的length大小，</span><br>    <span class="hljs-comment">// 之所以使用strncpy而不是memcpy,是因为strncpy会在目标缓存最后添加一个字符串结束符&#x27;\0&#x27;;</span><br>    <span class="hljs-comment">// strncpy函数在&lt;string.h&gt;头文件中</span><br>    <span class="hljs-built_in">strncpy</span>(argBuffer, argv[<span class="hljs-number">1</span>], length);<br><br>    <span class="hljs-type">char</span> result[<span class="hljs-number">32</span>];<br><br>    var state = CalculateArithmeticExpression(argBuffer, result);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The arithmetic expression to be calculated: %s\n&quot;</span>, argBuffer);<br><br>    <span class="hljs-keyword">if</span> (state)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The answer is: %s\n&quot;</span>, result);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Invalid expression!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h3><p>[1] C语言编程魔法书：基于C11标准<br>[2] <a href="https://github.com/zenny-chen/SimpleCalculator">https://github.com/zenny-chen/SimpleCalculator</a><br>[3] <a href="https://blog.csdn.net/chen1415886044/article/details/104370106">https://blog.csdn.net/chen1415886044/article/details/104370106</a></p>]]></content>
    
    
    <categories>
      
      <category>源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>C语言</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Visual Studio 2019中的添加及配置jsoncpp</title>
    <link href="/2023/04/05/ch20230405/"/>
    <url>/2023/04/05/ch20230405/</url>
    
    <content type="html"><![CDATA[<p>这里是Windows环境下在Visual Studio 2019中配置jsoncpp的方法以及jsoncpp的基本使用做一个记录。</p><h3 id="1-Visual-Studio-2019添加和配置jsoncpp"><a href="#1-Visual-Studio-2019添加和配置jsoncpp" class="headerlink" title="1. Visual Studio 2019添加和配置jsoncpp"></a>1. Visual Studio 2019添加和配置jsoncpp</h3><p>jsoncpp的下载地址[<a href="https://sourceforge.net/projects/jsoncpp/]%EF%BC%8C%E6%9C%AC%E6%96%87%E4%B8%AD%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF0.5.0%E7%89%88%E6%9C%AC%E3%80%82%E4%BD%BF%E7%94%A8jsoncpp%E4%B9%9F%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%B8%80%E7%A7%8D%E6%98%AF%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%8C%85%E5%90%ABcpp%E5%92%8Ch%E6%96%87%E4%BB%B6%EF%BC%8C%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%88%99%E6%98%AF%E4%BD%BF%E7%94%A8jsoncpp%E7%94%9F%E6%88%90%E7%9A%84lib%E6%96%87%E4%BB%B6%E3%80%82">https://sourceforge.net/projects/jsoncpp/]，本文中所使用的是0.5.0版本。使用jsoncpp也有两种方式，一种是在项目中包含cpp和h文件，第二种则是使用jsoncpp生成的lib文件。</a></p><h4 id="1-1-在项目种包含cpp和h文件"><a href="#1-1-在项目种包含cpp和h文件" class="headerlink" title="1.1 在项目种包含cpp和h文件"></a>1.1 在项目种包含cpp和h文件</h4><ol><li>解压下载的Jsoncpp文件，把jsoncpp-src-0.5.0文件拷贝到工程目录下；</li><li>将<code>jsoncpp-src-0.5.0\jsoncpp-src-0.5.0\include\json</code>和<code>jsoncpp-src-0.5.0\jsoncpp-src-0.5.0\src\lib_json</code>目录里的文件包含到VS工程中;<br> 具体地，在 菜单栏-&gt;项目 选项中，选择显示所有文件，然后在项目文件夹<code>jsoncpp-src-0.5.0\jsoncpp-src-0.5.0\include\json</code>和<code>jsoncpp-src-0.5.0\jsoncpp-src-0.5.0\src\lib_json</code>上右击，选择“包含在项目中”。</li><li>在VS工程的属性C&#x2F;C++下General（常规）中Additional Include Directories（附加包含目录）包含头文件目录.\jsoncpp-src-0.5.0\include。配置路径为：属性管理器 -&gt; C&#x2F;C++ -&gt; 常规 -&gt; 附加包含目录：<code>.\jsoncpp-src-0.5.0\include</code>。</li><li>在使用的cpp文件中包含json头文件即可，如：#include “json&#x2F;json.h”。</li><li>将json_reader.cpp、json_value.cpp和json_writer.cpp三个文件的Precompiled Header（预编译头）属性设置为Not Using Precompiled Headers（不使用预编译头），否则编译会出现错误。配置路径为：属性管理器 -&gt; C&#x2F;C++ -&gt; 预编译头 -&gt; 预编译头：不使用预编译头。</li></ol><h4 id="1-2-使用jsonCPP生成的静态lib库文件"><a href="#1-2-使用jsonCPP生成的静态lib库文件" class="headerlink" title="1.2 使用jsonCPP生成的静态lib库文件"></a>1.2 使用jsonCPP生成的静态lib库文件</h4><ol><li>解压下载的jsoncpp文件；</li><li>在jsoncpp-src-0.5.0&#x2F;makefiles&#x2F;vs71目录里找到jsoncpp.sln，使用visual studio打开，注意，本文所使用的是visual studio2019版本，在打开时会要求进行兼容选项，确认兼容升级即可；</li><li>生成解决方案，然后便可以在&#96;&#96;&#96;\jsoncpp-src-0.5.0\build\vs71\debug\lib_json&#96;&#96;中找到lib文件json_vc71_libmtd.lib，需要注意的是，如果选择的是release模式，则在release目录下存在生成的json_vc71_libmt.lib文件，文件名是不一样的！！！</li><li>新建一个空白测试项目，然后在项目中的连接器中链接lib文件，具体操作路径为：项目属性管理器 -&gt; 链接器 -&gt; 输入 -&gt; 附加依赖项 -&gt; lib的路径；</li><li>包含jsoncpp的include目录，其中包含.h头文件，具体操作路径为：属性管理器 -&gt; C&#x2F;C++ -&gt; 附加包含目录 -&gt; 编辑 -&gt; 添加路径<code>\jsoncpp-src-0.5.0\include</code>即可；</li><li>在测试cpp文件中，添加<code>#pragma comment(lib,&quot;json_vc71_libmtd.lib&quot;)</code>，并包含头文件<code>#include &quot;json/json.h&quot;</code>即可正常使用；</li></ol><p>NOTE：在测试运行时，需要在测试项目中使用与libku生成时使用一致的运行库，具体查看和操作路径为：属性管理器 -&gt; C&#x2F;C++ -&gt; 代码生成 -&gt; 运行库 -&gt; 多线程调试(&#x2F;MTd); 其中4个选项分别对应的含义如下：</p><ul><li>多线程调试Dll (&#x2F;MDd) 对应的是MD_DynamicDebug</li><li>多线程Dll (&#x2F;MD) 对应的是MD_DynamicRelease</li><li>多线程(&#x2F;MT) 对应的是MD_StaticRelease</li><li>多线程(&#x2F;MTd)对应的是MD_StaticDebug</li></ul><p>以下给出测试cpp代码, 该代码同样适用于1.1小节中的情况，只需注释或删除掉<code>#pragma comment(lib,&quot;json_vc71_libmtd.lib&quot;)</code>即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib,<span class="hljs-string">&quot;json_vc71_libmtd.lib&quot;</span>)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;json/json.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;&#123;\&quot;uploadid\&quot;: \&quot;UP000000\&quot;,\&quot;code\&quot;: 100,\&quot;msg\&quot;: \&quot;hello world\&quot;,\&quot;files\&quot;: \&quot;a.txt\&quot;&#125;&quot;</span>;<br><br>    Json::Reader reader;<br>    Json::Value root;<br>    <span class="hljs-keyword">if</span> (reader.<span class="hljs-built_in">parse</span>(str, root))  <span class="hljs-comment">// reader将Json字符串解析到root，root将包含Json里所有子元素  </span><br>    &#123;<br>        std::string upload_id = root[<span class="hljs-string">&quot;uploadid&quot;</span>].<span class="hljs-built_in">asString</span>();  <span class="hljs-comment">// 访问节点，upload_id = &quot;UP000000&quot;  </span><br><br>        <span class="hljs-type">int</span> code = root[<span class="hljs-string">&quot;code&quot;</span>].<span class="hljs-built_in">asInt</span>();    <span class="hljs-comment">// 访问节点，code = 100 </span><br>        std::string msg = root[<span class="hljs-string">&quot;msg&quot;</span>].<span class="hljs-built_in">asString</span>();<br>        std::string files = root[<span class="hljs-string">&quot;files&quot;</span>].<span class="hljs-built_in">asString</span>();<br>        cout &lt;&lt; upload_id &lt;&lt; <span class="hljs-string">&quot; : &quot;</span> &lt;&lt; code &lt;&lt; endl;<br>        cout &lt;&lt; msg &lt;&lt; <span class="hljs-string">&quot; : &quot;</span> &lt;&lt; files &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如有其他问题欢迎留言或私信讨论，谢谢。</p><h3 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h3><p>[1]<a href="https://blog.csdn.net/qq_40178343/article/details/112387810">https://blog.csdn.net/qq_40178343/article/details/112387810</a><br>[2]<a href="https://www.cnblogs.com/liaocheng/p/4243731.html">https://www.cnblogs.com/liaocheng/p/4243731.html</a><br>[3]<a href="https://blog.csdn.net/smalbig/article/details/113465183">https://blog.csdn.net/smalbig/article/details/113465183</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>C++</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows环境中C++遍历目录及文件</title>
    <link href="/2023/03/30/ch20230330/"/>
    <url>/2023/03/30/ch20230330/</url>
    
    <content type="html"><![CDATA[<p>这里记录的是在Windows环境下，如何遍历目录以及文件，其中分为两种情况，一种是遍历目录下的所有目录和文件，另一种是遍历目录里的所有文件，包括子目录，因此需要递归调用函数来实现。</p><h3 id="1-使用Windows-API遍历目录下的所有文件"><a href="#1-使用Windows-API遍历目录下的所有文件" class="headerlink" title="1.使用Windows API遍历目录下的所有文件"></a>1.使用Windows API遍历目录下的所有文件</h3><p>遍历某个目录下的所有文件，并输出文件名和文件大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listFile</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * dir)</span></span><br><span class="hljs-function"></span>&#123;<br>HANDLE hFind;<br>WIN32_FIND_DATA findData;<br>LARGE_INTEGER size;<br>hFind = <span class="hljs-built_in">FindFirstFile</span>(dir, &amp;findData);<br><span class="hljs-keyword">if</span> (hFind == INVALID_HANDLE_VALUE)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Failed to find first file!\n&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-comment">// 忽略&quot;.&quot;和&quot;..&quot;两种结果</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(findData.cFileName, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(findData.cFileName, <span class="hljs-string">&quot;..&quot;</span>) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (findData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)<span class="hljs-comment">// 判断是否是目录</span><br>&#123;<br>cout &lt;&lt; findData.cFileName &lt;&lt; <span class="hljs-string">&quot;\t &lt;dir&gt;\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>size.LowPart = findData.nFileSizeLow;<br>size.HighPart = findData.nFileSizeHigh;<br>cout &lt;&lt; findData.cFileName &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; size.QuadPart &lt;&lt; <span class="hljs-string">&quot; bytes\n&quot;</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">FindNextFile</span>(hFind, &amp;findData));<br>    <span class="hljs-built_in">FindClose</span>(hFind);<br>cout &lt;&lt; <span class="hljs-string">&quot;Done.\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> dir[<span class="hljs-number">100</span>];<br>cout &lt;&lt; <span class="hljs-string">&quot;Enter a directory (ends with \&#x27;\\\&#x27;): &quot;</span>;<br>cin.<span class="hljs-built_in">getline</span>(dir, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">strcat_s</span>(dir, <span class="hljs-string">&quot;*.*&quot;</span>);<span class="hljs-comment">// 需要在目录后面加上*.*表示所有目录文件</span><br><span class="hljs-built_in">listFile</span>(dir);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>NOTE: 在Visual Studio 2019中会出现“<code>&quot;const char *&quot; 类型的实参与 &quot;LPCWSTR&quot; 类型的形参不兼容</code>”的错误，该错误是由于vs使用的字符集为Unicode，解决办法是：在项目属性管理器-&gt;属性-&gt;高级-&gt;字符集，选择“使用多字节字符集”。</p><h3 id="2-使用Windows-API遍历目录里的所有文件"><a href="#2-使用Windows-API遍历目录里的所有文件" class="headerlink" title="2.使用Windows API遍历目录里的所有文件"></a>2.使用Windows API遍历目录里的所有文件</h3><p>遍历目录里的所有文件，其中包括子目录和子目录里的文件，与前一节类似，只需迭代调用listFiles函数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listFiles</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* dir)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-type">char</span> dir[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">memset</span>(dir, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Enter a directory (do not add \&#x27;\\\&#x27; in the end): &quot;</span>;<br>    cin.<span class="hljs-built_in">getline</span>(dir, <span class="hljs-number">100</span>);<br><br>    <span class="hljs-comment">//char dir[100] = &quot;G:\\Nessus\\&quot;;</span><br><br>    <span class="hljs-built_in">listFiles</span>(dir);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listFiles</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* dir)</span></span><br><span class="hljs-function"></span>&#123;<br><br>    HANDLE hFind;<br>    WIN32_FIND_DATA findData;<br>    LARGE_INTEGER size;<br>    <span class="hljs-type">char</span> dirNew[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">memset</span>(dirNew, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br><br>    <span class="hljs-comment">// 向目录加通配符，用于搜索第一个文件 </span><br>    <span class="hljs-built_in">strcpy</span>(dirNew, dir);<br>    <span class="hljs-built_in">strcat</span>(dirNew, <span class="hljs-string">&quot;\\*.*&quot;</span>);<br><br>    hFind = <span class="hljs-built_in">FindFirstFile</span>(dirNew, &amp;findData);<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-comment">// 是否是文件夹，并且名称不为&quot;.&quot;或&quot;..&quot; </span><br>        <span class="hljs-keyword">if</span> ((findData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) != <span class="hljs-number">0</span><br>            &amp;&amp; <span class="hljs-built_in">strcmp</span>(findData.cFileName, <span class="hljs-string">&quot;.&quot;</span>) != <span class="hljs-number">0</span><br>            &amp;&amp; <span class="hljs-built_in">strcmp</span>(findData.cFileName, <span class="hljs-string">&quot;..&quot;</span>) != <span class="hljs-number">0</span><br>            )<br>        &#123;<br>            <span class="hljs-comment">// 将dirNew设置为搜索到的目录，并进行下一轮搜索 </span><br>            <span class="hljs-built_in">strcpy</span>(dirNew, dir);<br>            <span class="hljs-built_in">strcat</span>(dirNew, <span class="hljs-string">&quot;\\&quot;</span>);<br>            <span class="hljs-built_in">strcat</span>(dirNew, findData.cFileName);<br>            <span class="hljs-built_in">listFiles</span>(dirNew);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            size.LowPart = findData.nFileSizeLow;<br>            size.HighPart = findData.nFileSizeHigh;<br>            cout &lt;&lt; findData.cFileName &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; size.QuadPart &lt;&lt; <span class="hljs-string">&quot; bytes\n&quot;</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">FindNextFile</span>(hFind, &amp;findData));<br><br>    <span class="hljs-built_in">FindClose</span>(hFind);<br>&#125;<br></code></pre></td></tr></table></figure><p>NOTE: 在某些机器中会出现输出”烫烫烫”的乱码错误，可能是由于字符串未初始化或者机器原因，我在个人电脑上就存在这个问题一直没有解决。</p><h3 id="3-使用io-h遍历目录下的所有文件"><a href="#3-使用io-h遍历目录下的所有文件" class="headerlink" title="3.使用io.h遍历目录下的所有文件"></a>3.使用io.h遍历目录下的所有文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;io.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listFiles</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* dir)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> dir[<span class="hljs-number">200</span>];<br><span class="hljs-built_in">memset</span>(dir, <span class="hljs-number">0</span>, <span class="hljs-number">200</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;Enter a directory ( ends with \&#x27;\\\&#x27;): &quot;</span>;<br>cin.<span class="hljs-built_in">getline</span>(dir, <span class="hljs-number">200</span>);<br><span class="hljs-built_in">strcat</span>(dir, <span class="hljs-string">&quot;*.*&quot;</span>);<span class="hljs-comment">// 在要遍历的目录后面加上通配符</span><br><span class="hljs-built_in">listFiles</span>(dir);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listFiles</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* dir)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">intptr_t</span> handle;<br><span class="hljs-type">_finddata_t</span> findData;<br><br>handle = _findfirst(dir, &amp;findData);<span class="hljs-comment">// 查找目录中的第一个文件</span><br><span class="hljs-keyword">if</span> (handle == <span class="hljs-number">-1</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Failed to find the first file!&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-comment">// 判断是否为子目录，且不是&quot;.&quot;和&quot;..&quot;</span><br><span class="hljs-keyword">if</span> (findData.attrib &amp; _A_SUBDIR <br>&amp;&amp; <span class="hljs-built_in">strcmp</span>(findData.name, <span class="hljs-string">&quot;.&quot;</span>) != <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(findData.name, <span class="hljs-string">&quot;..&quot;</span>) != <span class="hljs-number">0</span>)<br>&#123;<br>cout &lt;&lt; findData.name &lt;&lt; <span class="hljs-string">&quot;\t&lt;dir&gt;&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; findData.name &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; findData.size &lt;&lt; endl;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (_findnext(handle, &amp;findData)==<span class="hljs-number">0</span>);<span class="hljs-comment">// 查找目录中的下一个文件</span><br><br>_findclose(handle);<span class="hljs-comment">// 关闭搜索句柄</span><br>&#125;<br></code></pre></td></tr></table></figure><p>NOTE: 虽然在Linux系统中也可以使用<code>#include &lt;sys/io.h&gt;</code>, 但是似乎由于io.h可能存在跨平台不兼容的问题，因此在Windows中会出现问题。</p><h3 id="4-使用io-h遍历目录里的所有文件"><a href="#4-使用io-h遍历目录里的所有文件" class="headerlink" title="4.使用io.h遍历目录里的所有文件"></a>4.使用io.h遍历目录里的所有文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;io.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listFiles</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* dir)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> dir[<span class="hljs-number">200</span>];<br><span class="hljs-built_in">memset</span>(dir, <span class="hljs-number">0x00</span>, <span class="hljs-number">200</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;Enter a directory (ends with \&#x27;\\\&#x27;): &quot;</span>;<br>cin.<span class="hljs-built_in">getline</span>(dir, <span class="hljs-number">200</span>);<br><br><span class="hljs-built_in">listFiles</span>(dir);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listFiles</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* dir)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> dirNew[<span class="hljs-number">200</span>];<br><span class="hljs-built_in">memset</span>(dirNew, <span class="hljs-number">0x00</span>, <span class="hljs-number">200</span>);<br><span class="hljs-built_in">strcpy</span>(dirNew, dir);<br><span class="hljs-built_in">strcat</span>(dirNew, <span class="hljs-string">&quot;\\*.*&quot;</span>);<br><br><span class="hljs-type">intptr_t</span> handle;<br><span class="hljs-type">_finddata_t</span> findData;<br>handle = _findfirst(dirNew, &amp;findData);<br><span class="hljs-keyword">if</span> (handle == <span class="hljs-number">-1</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Failed to find the first file!\n&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-keyword">if</span> (findData.attrib &amp; _A_SUBDIR)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(findData.name, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(findData.name, <span class="hljs-string">&quot;..&quot;</span>) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>cout &lt;&lt; findData.name &lt;&lt; <span class="hljs-string">&quot;\t&lt;dir&gt;\n&quot;</span>;<br><br><span class="hljs-built_in">strcpy</span>(dirNew, dir);<br><span class="hljs-built_in">strcat</span>(dirNew, <span class="hljs-string">&quot;\\&quot;</span>);<br><span class="hljs-built_in">strcat</span>(dirNew, findData.name);<br><br><span class="hljs-built_in">listFiles</span>(dirNew);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; findData.name &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; findData.size &lt;&lt;<span class="hljs-string">&quot;bytes&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (_findnext(handle, &amp;findData)==<span class="hljs-number">0</span>);<br><br>_findclose(handle);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h3><p>[1] <a href="https://www.cnblogs.com/collectionne/p/6792301.html">https://www.cnblogs.com/collectionne/p/6792301.html</a><br>[2] <a href="https://www.cnblogs.com/collectionne/p/6815924.html">https://www.cnblogs.com/collectionne/p/6815924.html</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>C++</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统编程01——Linux系统目录结构及常用命令</title>
    <link href="/2023/01/16/LinuxSys-01/"/>
    <url>/2023/01/16/LinuxSys-01/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Linux下的目录结构"><a href="#1-Linux下的目录结构" class="headerlink" title="1.Linux下的目录结构"></a>1.Linux下的目录结构</h3><ol><li>Linux系统的目录结构<br><img src="/2023/01/16/LinuxSys-01/01.png" alt="linux系统目录结构"></li></ol><ul><li>&#x2F;bin: binary, 二进制文件, 可执行程序, shell命令等; 如: ls, rm, mv, cp等常用命令;</li><li>&#x2F;sbin: s是Super User的意思，存放系统管理员使用的系统管理程序，如：ifconfig, halt, shutdown, reboot等系统命令;</li><li>&#x2F;dev: device, 在Linux下一切皆文件，如硬盘, 显卡，显示器；字符设备文件，块设备文件(例如：在input目录下执行<code>sudo cat mouse0</code>, 移动鼠标会显示有输入);</li><li>&#x2F;lib: Linux运行时需要加载的一些动态库，如: <code>libc.so, libpthread.so</code>等;</li><li>&#x2F;mnt: 手动挂载的目录，如U盘等；</li><li>&#x2F;media: 外设的自动挂载目录，如光驱等;</li><li>&#x2F;root: Linux超级用户root的家目录;</li><li>&#x2F;usr: unix system resource 类似于Windows中的program files目录<ul><li>include目录中存放的头文件，如: stdio.h, stdlib.h, string.h, pthread.h;</li><li>games目录中存放的小游戏, 如: sl 小火车游戏</li></ul></li><li>&#x2F;etc: 存放配置文件，<ul><li>&#x2F;etc&#x2F;passwd: <code>man 5 passwd</code> 可以查看passwd文件的格式信息；</li><li>&#x2F;etc&#x2F;group: <code>man 5 group</code> 可以查看group文件的格式信息；</li><li>&#x2F;etc&#x2F;profile: 系统的配置文件，修改该文件会影响系统下的所有用户；</li></ul></li><li>&#x2F;opt: 安装第三方应用程序， 如安装数据库便可以安装在该目录下；</li><li>&#x2F;home: Linux系统所有用户的家目录</li><li>&#x2F;tmp: 存放临时文件， 新建在该目录下的文件会在系统重启后自动清除；</li></ul><ol start="2"><li>绝对路径与相对路径</li></ol><ul><li>绝对路径：从根目录开始表示的路径，即从 &#x2F;(斜杠) 开始, 如：<code>/home/user</code>;</li><li>相对路径：从当前所处的目录开始表示的路径<ul><li>. 表示当前目录;</li><li>.. 表示当前目录的上一级目录;</li></ul></li></ul><ol start="3"><li>Linux中的命令提示符</li></ol><ul><li><code>~$</code>: 表示当前用户为普通用户;</li><li><code>~#</code>: 表示当前用户为root用户;</li></ul><h3 id="2-文件和目录操作相关命令"><a href="#2-文件和目录操作相关命令" class="headerlink" title="2. 文件和目录操作相关命令"></a>2. 文件和目录操作相关命令</h3><ol><li>tree命令</li></ol><ul><li>以树状形式查看指定目录内容，使用该命令需要安装软件tree  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ./bash">sudo apt-get update<br>sudo apt-get install tree<br></code></pre></td></tr></table></figure></li><li>使用方法：  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">tree <span class="hljs-comment"># 树形结构显示当前目录下的文件信息</span><br>tree 目录   <span class="hljs-comment"># 树形结构显示指定目录下的文件信息</span><br>如：tree <span class="hljs-regexp">/home/</span><br></code></pre></td></tr></table></figure>使用tree命令查看目录内容层次清晰，tree命令只能查看目录内容，不能查看普通文件内容；</li></ul><ol start="2"><li>ls命令</li></ol><ul><li>查看指定目录下的文件信息</li><li>使用方法：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span>  <span class="hljs-comment"># 显示当前目录下的文件信息</span><br><span class="hljs-built_in">ls</span>  目录    <span class="hljs-comment"># 显示指定目录下的文件信息</span><br></code></pre></td></tr></table></figure></li><li>相关参数<ul><li>-a: 列出当前目录下的所有文件，包括：</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>C语言</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深信服面试手写代码：复杂链表的复制</title>
    <link href="/2022/10/12/ch20221012-01/"/>
    <url>/2022/10/12/ch20221012-01/</url>
    
    <content type="html"><![CDATA[<p>深信服手撕代码，要求实现一个函数复制一个复杂链表，复杂链表中有一个随机指针可以指向任意节点或者nullptr；<br>leetcode以及剑指offer中有这一题，<a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">leetcode</a>, <a href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指offer</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ComplexListNode</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    ComplexListNode *next;<br>    ComplexListNode *random;<br>    <span class="hljs-built_in">ComplexListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">random</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1-构建复杂链表"><a href="#1-构建复杂链表" class="headerlink" title="1. 构建复杂链表"></a>1. 构建复杂链表</h3><p>首先需要知道如何构建复杂链表，当然在做题和面试时，只需要实现复制链表的函数即可。<br>这里的思路是分两次进行，首先遍历数组，取元素第一个值来构建单向链表, 同时构建一个数组tmp来存放每一个节点；然后再次遍历数组，取元素第二个值作为下标索引取出tmp中的节点，并将当前节点的随机指针指向该节点，当前节点不断后移；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ComplexListNode *<span class="hljs-title">constructComplexList</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    ComplexListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ComplexListNode</span>(<span class="hljs-number">0</span>);<br>    ComplexListNode *cur = dummy;<br>    vector&lt;ComplexListNode *&gt; temp;<br>    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt; &amp;n : nums)<br>    &#123;<br>        cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ComplexListNode</span>(n[<span class="hljs-number">0</span>]);<br>        cur = cur-&gt;next;<br>        temp.<span class="hljs-built_in">push_back</span>(cur);<br>    &#125;<br>    cur = dummy-&gt;next;<br>    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt; &amp;n : nums)<br>    &#123;<br>        cur-&gt;random = temp[n[<span class="hljs-number">1</span>]];<br>        cur = cur-&gt;next;<br>    &#125;<br>    ComplexListNode *head = dummy-&gt;next;<br>    head-&gt;random = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">delete</span> dummy;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者使用unordered_map来存储已构建的节点也可以</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ComplexListNode *<span class="hljs-title">constructComplexList_2</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    ComplexListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ComplexListNode</span>(<span class="hljs-number">0</span>);<br>    ComplexListNode *cur = dummy;<br>    unordered_map&lt;<span class="hljs-type">int</span>, ComplexListNode *&gt; mp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        ComplexListNode *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ComplexListNode</span>(nums[i][<span class="hljs-number">0</span>]);<br>        mp[i] = node;<br>        cur-&gt;next = node;<br>        cur = cur-&gt;next;<br>    &#125;<br>    cur = dummy-&gt;next;<br>    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt; &amp;n : nums)<br>    &#123;<br>        cur-&gt;random = mp[n[<span class="hljs-number">1</span>]];<br>        cur = cur-&gt;next;<br>    &#125;<br>    ComplexListNode *head = dummy-&gt;next;<br>    head-&gt;random = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">delete</span> dummy;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-复制复杂链表"><a href="#2-复制复杂链表" class="headerlink" title="2. 复制复杂链表"></a>2. 复制复杂链表</h3><p>在这里复制复杂链表应该使用深拷贝的原理，即对于原链表的每一个节点都重新创建并开辟出一块新空间，而不是简单的指向原来的节点；<br>思路：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ComplexListNode *<span class="hljs-title">copyComplexList</span><span class="hljs-params">(ComplexListNode *head)</span></span><br><span class="hljs-function"></span>&#123;<br>    unordered_map&lt;ComplexListNode *, ComplexListNode *&gt; mp;<br>    ComplexListNode *cur = head;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        mp[cur] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ComplexListNode</span>(cur-&gt;val);<br>        cur = cur-&gt;next;<br>    &#125;<br>    cur = head;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        mp[cur]-&gt;next = mp[cur-&gt;next];<br>        mp[cur]-&gt;random = mp[cur-&gt;random];<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>C++， 面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++实现单/双链表的反转以及复制</title>
    <link href="/2022/10/12/ch20221012/"/>
    <url>/2022/10/12/ch20221012/</url>
    
    <content type="html"><![CDATA[<h3 id="1-构建单向链表"><a href="#1-构建单向链表" class="headerlink" title="1. 构建单向链表"></a>1. 构建单向链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode* next;<br>    <span class="hljs-built_in">ListNode</span>():<span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x):<span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x, ListNode* next):<span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(next)&#123;&#125;<br>&#125;;<br><br><span class="hljs-function">ListNode* <span class="hljs-title">constructList</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>    ListNode* cur = dummy;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums)<br>    &#123;<br>        cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(i);<br>        cur = cur-&gt;next;<br>    &#125;<br>    ListNode* head = dummy-&gt;next;<br>    <span class="hljs-keyword">delete</span> dummy;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-C-反转单向链表的四种方式"><a href="#2-C-反转单向链表的四种方式" class="headerlink" title="2. C++反转单向链表的四种方式"></a>2. C++反转单向链表的四种方式</h3><h4 id="1-迭代法"><a href="#1-迭代法" class="headerlink" title="1. 迭代法"></a>1. 迭代法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 迭代方法</span><br><span class="hljs-function">ListNode* <span class="hljs-title">reverseList_1</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function"></span>&#123;<br>    ListNode* prev = <span class="hljs-literal">nullptr</span>;<br>    ListNode* next = <span class="hljs-literal">nullptr</span>;<br>    ListNode* cur = head;<br>    <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-comment">// 先保存当前节点的下一个节点;</span><br>        next = cur-&gt;next;<br>        <span class="hljs-comment">// 将当前节点的下一个指向它的前一个;</span><br>        cur-&gt;next = prev;<br>        <span class="hljs-comment">// 将当前节点作为前置节点</span><br>        prev = cur;<br>        <span class="hljs-comment">// 当前节点移动至保存的下一节点</span><br>        cur = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-递归方法"><a href="#2-递归方法" class="headerlink" title="2. 递归方法"></a>2. 递归方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 递归方法</span><br><span class="hljs-function">ListNode* <span class="hljs-title">reverseList_2</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 递归出口, 当空链表或者只有一个节点时,直接返回</span><br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-comment">// 一直递归找到链表中的最后一个节点</span><br>    ListNode* newHead = <span class="hljs-built_in">reverseList_2</span>(head-&gt;next);<br>    <span class="hljs-comment">// 在两个节点之间交换,第一个节点的next就是第二个节点,因此head-&gt;next-&gt;next就是第二个节点的next指针,将其指向第一个节点head</span><br>    head-&gt;next-&gt;next = head;<br>    <span class="hljs-comment">// 将第一个节点的next置为null</span><br>    head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// 每一层递归结束,将新的头节点返回给上一层,保证整个递归过程能够一直找到新链表的表头</span><br>    <span class="hljs-keyword">return</span> newHead;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-头插法"><a href="#3-头插法" class="headerlink" title="3. 头插法"></a>3. 头插法</h4><p>在原有链表的基础上,依次将位于链表头部的节点摘下,然后采用从头部插入的方式生成一个新链表,生成的新链表即为原链表的反转;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">reverseList_3</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode* newHead = <span class="hljs-literal">nullptr</span>;<br>    ListNode* temp = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        temp = head;<br>        <span class="hljs-comment">// 将头节点从原链表中摘下</span><br>        head = head-&gt;next;<br>        <span class="hljs-comment">// 将temp插入到newHead的头部</span><br>        temp-&gt;next = newHead;<br>        <span class="hljs-comment">// 头部往前移动</span><br>        newHead = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newHead;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-原地反转"><a href="#4-原地反转" class="headerlink" title="4. 原地反转"></a>4. 原地反转</h4><p>与头插法类似,区别在于不需要建立一个新链表,而是直接对原链表做修改来实现,需要两个辅助指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">reverseList_4</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode* begin = head;<br>    ListNode* end = head-&gt;next;<br>    <span class="hljs-keyword">while</span> (end != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-comment">// 将第一个节点的下一个指向end的下一个,即第三个节点,</span><br>        begin-&gt;next = end-&gt;next;<br>        <span class="hljs-comment">// 将end即第二个节点插入到头节点的前面</span><br>        end-&gt;next = head;<br>        <span class="hljs-comment">// 将插入的新节点作为新的头节点</span><br>        head = end;<br>        <span class="hljs-comment">// 第一个节点的下一个作为第二个节点, 而begin始终都是原来的第一个节点,或者说是原始头节点</span><br>        end = begin-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">// 返回新的头节点</span><br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-构建双向链表"><a href="#3-构建双向链表" class="headerlink" title="3. 构建双向链表"></a>3. 构建双向链表</h3><p>双向链表与单向链表的不同在于,双向链表多了一个指向直接前驱节点的prev指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DoubleListNode</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    DoubleListNode *next;<br>    DoubleListNode *prev;<br>    <span class="hljs-built_in">DoubleListNode</span>() : <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">DoubleListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">DoubleListNode</span>(<span class="hljs-type">int</span> x, DoubleListNode *next, DoubleListNode *prev) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(next), <span class="hljs-built_in">prev</span>(prev) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function">DoubleListNode *<span class="hljs-title">constructDoubleList</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    DoubleListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DoubleListNode</span>(<span class="hljs-number">0</span>);<br>    DoubleListNode *cur = dummy;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums)<br>    &#123;<br>        DoubleListNode *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DoubleListNode</span>(i);<br>        cur-&gt;next = node;<br>        node-&gt;prev = cur;<br>        cur = cur-&gt;next;<br>    &#125;<br>    DoubleListNode *head = dummy-&gt;next;<br>    head-&gt;prev = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">delete</span> dummy;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-双向链表的反转"><a href="#4-双向链表的反转" class="headerlink" title="4. 双向链表的反转"></a>4. 双向链表的反转</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DoubleListNode *<span class="hljs-title">reversList</span><span class="hljs-params">(DoubleListNode *head)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    DoubleListNode *prev = <span class="hljs-literal">nullptr</span>;<br>    DoubleListNode *next = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        next = head-&gt;next;<br>        head-&gt;next = prev;<br>        head-&gt;prev = next;<br>        prev = head;<br>        head = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解C++中的强制类型转换</title>
    <link href="/2022/10/09/ch20221009/"/>
    <url>/2022/10/09/ch20221009/</url>
    
    <content type="html"><![CDATA[<h3 id="深入理解C-中的强制类型转换"><a href="#深入理解C-中的强制类型转换" class="headerlink" title="深入理解C++中的强制类型转换"></a>深入理解C++中的强制类型转换</h3><p>C语言强制类型转换主要用于基础的数据类型间的转换，C++除了能使用c语言的强制类型转换外，还新增了四种强制类型转换：static_cast、dynamic_cast、const_cast、reinterpret_cast，主要运用于继承关系类间的强制转化.</p><h4 id="1-dynamic-cast"><a href="#1-dynamic-cast" class="headerlink" title="1. dynamic_cast"></a>1. dynamic_cast</h4><p>格式： <code>dynamic_cast &lt; type-id &gt; ( expression)</code><br>将expression转换为type-id类型的对象，其中，type-id可以是类的指针、类的引用或者是void*， 如果type-id是类指针类型，则expression也必须是一个指针，如果type-id是一个类的引用，则expression也必须是一个引用。<br>作用：<br>dynamic_cast将一个基类对象的指针或引用转换到继承类指针或引用，其会根据基类指针是否真正指向继承类指针来作相应处理</p><ul><li>若对类指针进行dynamic_cast，失败返回null, 成功则返回正常的cast之后的对象指针；</li><li>若对类引用进行dynamic_cast， 失败会抛出异常，成功则返回正常cast之后的对象引用；<br>注意：</li><li>dynamic_cast在将父类cast到子类时，父类必须要有虚函数，否则编译器会报错。</li><li>dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。</li><li>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    string name;<br>    <span class="hljs-type">int</span> age;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;class People: name=[&quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;]&quot;</span><br>             &lt;&lt; <span class="hljs-string">&quot;age=[&quot;</span> &lt;&lt; age &lt;&lt; <span class="hljs-string">&quot;]&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">public</span> People<br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> classId;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;class Student: id=[&quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot;]&quot;</span><br>             &lt;&lt; <span class="hljs-string">&quot;classId=[&quot;</span> &lt;&lt; classId &lt;&lt; <span class="hljs-string">&quot;]&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    People p;<br>    Student s;<br>    s.data = <span class="hljs-number">100</span>;<br><br>    People *pp;<br>    Student *ps;<br><br>    <span class="hljs-comment">// 上行转换，没有问题，多态有效</span><br>    ps = &amp;s;<br>    pp = <span class="hljs-built_in">dynamic_cast</span>&lt;People *&gt;(ps);<br>    pp-&gt;<span class="hljs-built_in">print</span>();<br><br>    <span class="hljs-comment">// 下行转换: pp父类指针实际指向子类对象，没有问题</span><br>    pp = &amp;s;<br>    ps = <span class="hljs-built_in">dynamic_cast</span>&lt;Student *&gt;(pp);<br>    ps-&gt;<span class="hljs-built_in">print</span>();<br>    cout &lt;&lt; ps-&gt;data &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 下行转换：pp实际指向父类对象，含有不安全操作，dynamic_cast发挥作用，返回NULL</span><br>    pp = &amp;p;<br>    ps = <span class="hljs-built_in">dynamic_cast</span>&lt;Student *&gt;(pp);<br>    <span class="hljs-built_in">assert</span>(ps != <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 违背断言，阻止以下不安全操作</span><br>    ps-&gt;<span class="hljs-built_in">print</span>();<br>    cout &lt;&lt; ps-&gt;data &lt;&lt; endl; <span class="hljs-comment">// 不安全操作，对象实例根本没有data成员</span><br><br>    <span class="hljs-comment">// 下行转换：pp实际指向父类对象，含有不安全操作，static_cast无视</span><br>    pp = &amp;p;<br>    ps = <span class="hljs-built_in">static_cast</span>&lt;Student *&gt;(pp);<br>    <span class="hljs-built_in">assert</span>(ps != <span class="hljs-literal">NULL</span>);<br>    ps-&gt;<span class="hljs-built_in">print</span>();<br>    cout &lt;&lt; ps-&gt;data &lt;&lt; endl; <span class="hljs-comment">// 不安全操作，对象实例根本没有data成员</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-const-cast"><a href="#2-const-cast" class="headerlink" title="2. const_cast"></a>2. const_cast</h4><p>const_cast是将常量转换成非常量，用于修改类型的const或volatile属性，不能对非指针或非引用的变量添加或移除const。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> g = <span class="hljs-number">20</span>;<br>    cout &lt;&lt; g &lt;&lt; endl;<br>    <span class="hljs-comment">// int h = const_cast&lt;int&gt;(g); //不允许对普通数据进行操作</span><br>    <span class="hljs-type">int</span> *h = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span> *&gt;(&amp;g); <span class="hljs-comment">//去掉const常量const属性</span><br>    cout &lt;&lt; *h &lt;&lt; endl;<br>    *h = <span class="hljs-number">30</span>;<br>    cout &lt;&lt; *h &lt;&lt; endl;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> g0 = <span class="hljs-number">20</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;g2 = g0;<br>    cout &lt;&lt; g0 &lt;&lt; endl;<br>    cout &lt;&lt; g2 &lt;&lt; endl;<br>    <span class="hljs-type">int</span> &amp;h1 = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span> &amp;&gt;(g0); <span class="hljs-comment">//去掉const引用const属性</span><br>    <span class="hljs-type">int</span> &amp;h2 = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span> &amp;&gt;(g2); <span class="hljs-comment">//去掉const引用const属性</span><br>    cout &lt;&lt; h1 &lt;&lt; endl;<br>    cout &lt;&lt; h2 &lt;&lt; endl;<br>    h1 = <span class="hljs-number">30</span>;<br>    h2 = <span class="hljs-number">30</span>;<br>    cout &lt;&lt; h1 &lt;&lt; endl;<br>    cout &lt;&lt; h2 &lt;&lt; endl;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *g1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-type">char</span> *h3 = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(g1); <span class="hljs-comment">//去掉const指针const属性</span><br>    cout &lt;&lt; h3 &lt;&lt; endl;<br>    <span class="hljs-type">char</span> g3[] = <span class="hljs-string">&quot;world&quot;</span>;<br>    h3 = g3;<br>    cout &lt;&lt; h3 &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-static-cast-静态转换"><a href="#3-static-cast-静态转换" class="headerlink" title="3. static_cast 静态转换"></a>3. static_cast 静态转换</h4><p>static_cast静态转换相当于C语言中的强制转换，但不能实现普通指针数据（空指针除外）的强制转换，一般用于父类和子类指针、引用间的相互转换。</p><ol><li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。不管是否发生多态，父子之间互转时，编译器都不会报错。</li></ol><ul><li>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；</li><li>进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的，但是编译器不会报错。</li></ul><ol start="2"><li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。</li><li>把空指针转换成目标类型的空指针。</li><li>把任何指针类型转换成空指针类型。</li><li>可以对普通数据的const和non_const进行转换，但不能对普通数据取地址后的指针进行const添加和消去。</li><li>无继承关系的自定义类型，不可转换，不支持类间交叉转换。<br>注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> :<span class="hljs-keyword">public</span> Person&#123;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">My</span>&#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> a = <span class="hljs-string">&#x27;c&#x27;</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt; (a);<br>    cout &lt;&lt; b &lt;&lt; endl;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> a0 = <span class="hljs-string">&#x27;c&#x27;</span>;<br>    <span class="hljs-type">char</span> b0 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt; (a0);<br>    cout &lt;&lt; b0 &lt;&lt; endl;<br><br>    <span class="hljs-type">char</span> a1 = <span class="hljs-string">&#x27;c&#x27;</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> b1 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>&gt; (a1);<br>    cout &lt;&lt; b1 &lt;&lt; endl;<br><br>    <span class="hljs-comment">//static无法丢掉常量或其他类型限定符，只限于对常量地址的指针去const</span><br>    <span class="hljs-comment">//const char a2 = &#x27;c&#x27;;</span><br>    <span class="hljs-comment">//char *b2 = static_cast&lt;char*&gt; (&amp;a2);</span><br>    <span class="hljs-comment">//cout &lt;&lt; b2 &lt;&lt; endl;</span><br><br><br>    <span class="hljs-comment">//父类指针转为子类</span><br>    Person *p = <span class="hljs-literal">NULL</span>;<br>    Son *s = <span class="hljs-built_in">static_cast</span>&lt;Son*&gt;(p);<br><br>    <span class="hljs-comment">//子类指针转为父类</span><br>    Son *s0 = <span class="hljs-literal">NULL</span>;<br>    Person *p0 = <span class="hljs-built_in">static_cast</span>&lt;Person*&gt;(s0);<br><br>    <span class="hljs-comment">//My* my= static_cast&lt;My*&gt;(p); 无继承关系的自定义数据类型不能相互转换</span><br><br>    <span class="hljs-comment">//父类对象无法转为子类对象</span><br>    <span class="hljs-comment">//Person p1;</span><br>    <span class="hljs-comment">//Son s1 = static_cast&lt;Son&gt;(p1);</span><br><br>    <span class="hljs-comment">//子类对象可以赋值，初始化父类对象</span><br>    Son s2;<br>    Person p2 = <span class="hljs-built_in">static_cast</span>&lt;Person&gt;(s2);<br><br>    <span class="hljs-comment">//父类引用转为子类</span><br>    Person p_ ;<br>    Person &amp;p3 = p_;<br>    Son &amp;s3 = <span class="hljs-built_in">static_cast</span>&lt;Son&amp;&gt;(p3);<br><br>    <span class="hljs-comment">//子类引用转为父类</span><br>    Son s_;<br>    Son &amp;s4 = s_;<br>    Person &amp;p4 = <span class="hljs-built_in">static_cast</span>&lt;Person&amp;&gt;(s4);<br><br>    <span class="hljs-comment">//空指针转化为目标类型的指针</span><br>    <span class="hljs-type">void</span> *pPtr = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> *iPtr = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(pPtr);<br><br>    <span class="hljs-comment">//任何指针转化为空指针类型</span><br>    <span class="hljs-type">int</span> *aInt = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">void</span> *aVoid = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(aInt);<br><br>    <span class="hljs-comment">//static_cast不能进行出void外的指针强制互转</span><br>    <span class="hljs-type">char</span> *tmp = <span class="hljs-string">&quot;abc&quot;</span>;<br>    cout &lt;&lt; tmp &lt;&lt; endl;<br><br>    <span class="hljs-comment">//cout &lt;&lt; static_cast&lt;int*&gt;(tmp) &lt;&lt; endl;不能将char*型的数据转换为int*，但C语言强转可以</span><br>    cout &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(tmp) &lt;&lt; endl;<br><br>    <span class="hljs-type">int</span> *tmp_ = (<span class="hljs-type">int</span>*)(tmp);<br>    cout &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(tmp_) &lt;&lt; endl;<br><br>    <span class="hljs-type">int</span> *tmpInt = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; tmpInt &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(tmpInt) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(tmpInt) &lt;&lt; endl;<span class="hljs-comment">//转为自身可以</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="4-reinterpret-cast-重新解释转换"><a href="#4-reinterpret-cast-重新解释转换" class="headerlink" title="4. reinterpret_cast 重新解释转换"></a>4. reinterpret_cast 重新解释转换</h4><p>最鸡肋的转换函数，可以将任意类型转换为任意类型，因此非常不安全。只有将转换后的类型值转换回到其原始类型，这样才是正确使用reinterpret_cast方式</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解C++中的友元</title>
    <link href="/2022/10/08/ch20221008/"/>
    <url>/2022/10/08/ch20221008/</url>
    
    <content type="html"><![CDATA[<h3 id="关于友元函数和友元类"><a href="#关于友元函数和友元类" class="headerlink" title="关于友元函数和友元类"></a>关于友元函数和友元类</h3><h4 id="1-将非成员函数设置为类的友元函数"><a href="#1-将非成员函数设置为类的友元函数" class="headerlink" title="1. 将非成员函数设置为类的友元函数"></a>1. 将非成员函数设置为类的友元函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> id;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">int</span> sid, string sname, <span class="hljs-type">int</span> sage) : <span class="hljs-built_in">age</span>(sage), <span class="hljs-built_in">id</span>(sid), <span class="hljs-built_in">name</span>(sname)&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Student *s)</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Student *s)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; s-&gt;id &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; s-&gt;name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; s-&gt;age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Student <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-built_in">show</span>(&amp;s);<br><br>    Student *ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Student</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br>    <span class="hljs-built_in">show</span>(ps);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过将非成员函数show设置为Student类的友元函数，使得show能够访问Student类中的私有成员变量；</p><h4 id="2-将成员函数设置为类的友元函数"><a href="#2-将成员函数设置为类的友元函数" class="headerlink" title="2. 将成员函数设置为类的友元函数"></a>2. 将成员函数设置为类的友元函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>;  <span class="hljs-comment">// 由于Student类中需要用到Teacher类，所以需要先声明类</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> id;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">int</span> sid, string sname, <span class="hljs-type">int</span> sage) : <span class="hljs-built_in">age</span>(sage), <span class="hljs-built_in">id</span>(sid), <span class="hljs-built_in">name</span>(sname)&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showTeacher</span><span class="hljs-params">(Teacher *teacher)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    string name;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Teacher</span>(string tname) : <span class="hljs-built_in">name</span>(tname)&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">Student::showTeacher</span><span class="hljs-params">(Teacher *teacher)</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Student::showTeacher</span><span class="hljs-params">(Teacher *teacher)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; teacher-&gt;name &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Student <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-function">Teacher <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-string">&quot;里斯&quot;</span>)</span></span>;<br>    s.<span class="hljs-built_in">showTeacher</span>(&amp;t);<br><br>    Student *ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Student</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br>    Teacher *pt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Teacher</span>(<span class="hljs-string">&quot;里斯&quot;</span>);<br>    ps-&gt;<span class="hljs-built_in">showTeacher</span>(pt);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过在Teacher类中将Student类中的成员函数showTeacher设置为友元函数，从而使得在Student类中可以访问Teacher类中的私有成员变量name;</p><h4 id="3-友元类"><a href="#3-友元类" class="headerlink" title="3. 友元类"></a>3. 友元类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> id;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; age &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">int</span> sid, string sname, <span class="hljs-type">int</span> sage) : <span class="hljs-built_in">age</span>(sage), <span class="hljs-built_in">id</span>(sid), <span class="hljs-built_in">name</span>(sname)&#123;&#125;;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    string name;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Teacher</span>(string tname) : <span class="hljs-built_in">name</span>(tname)&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Student *s)</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Teacher::show</span><span class="hljs-params">(Student *s)</span></span><br><span class="hljs-function"></span>&#123;<br>    s-&gt;<span class="hljs-built_in">print</span>();<br>    cout &lt;&lt; s-&gt;id &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; s-&gt;name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; s-&gt;age &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; name &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Student <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-function">Teacher <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-string">&quot;里斯&quot;</span>)</span></span>;<br>    t.<span class="hljs-built_in">show</span>(&amp;s);<br><br>    Student *ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Student</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">18</span>);<br>    Teacher *pt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Teacher</span>(<span class="hljs-string">&quot;里斯&quot;</span>);<br>    pt-&gt;<span class="hljs-built_in">show</span>(ps);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Student类中将Teacher类声明为自己的友元类，使得Teacher类中能够使用Student类中的私有成员变量和成员函数；</p><ol><li>将类 B 声明为类 A 的友元类，那么类 B 中的所有成员函数都是类 A 的友元函数，可以访问类 A 的所有成员，包括 public、protected、private 属性的。</li><li>一个函数可以被多个类声明为友元函数，这样就可以访问多个类中的 private 成员。</li><li>友元的关系是单向的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员。</li><li>友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。</li><li>除非有必要，一般不建议把整个类声明为友元类，而只将某些成员函数声明为友元函数，这样更安全一些。</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++知识点总结p1</title>
    <link href="/2022/10/07/ch20221007/"/>
    <url>/2022/10/07/ch20221007/</url>
    
    <content type="html"><![CDATA[<h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h3><ol><li>如果在函数的内部定义了某种内置类型的数组，那么数组的默认初始化会令数组含有未定义的值；</li><li>定义数组时，必须指定数组的类型，不允许使用auto关键字由初始值的列表推断类型；</li><li>数组与vector一样，数组的元素应该为对象，不存在引用的数组；</li><li>如果数组维度比提供的初始值数量大，则剩余的元素会被初始化为默认值，例如0值、空字符串等；</li><li>不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值；某些编译器支持数组的赋值是由于<strong>编译器扩展</strong>；</li></ol><h3 id="2-C风格字符串"><a href="#2-C风格字符串" class="headerlink" title="2.C风格字符串"></a>2.C风格字符串</h3><ol><li>使用比较运算符对C风格的字符串进行比较时，实际比较的是指针，即两个字符数组的地址，而非字符串本身，应该使用<strong>strcmp函数</strong>；</li><li>在C++中字符串比较：<ol><li>比较规则：<ol><li>按顺序从前往后比较；</li><li>同序号的字符按ASCII码值比较</li><li>直到遇到对应字符不等或者字符串结束</li></ol></li><li>采用比较运算符比较，返回值为bool类型</li></ol></li><li>在C风格字符串中比较：<ol><li>使用strcmp函数进行比较：<code>int strcmp(const char* str1, const char* str2)</code></li><li>如果两个字符串相同则返回0，str1&gt;str2返回1，str1 &lt; str2, 返回-1；</li></ol></li></ol><h3 id="3-变量初始化"><a href="#3-变量初始化" class="headerlink" title="3.变量初始化"></a>3.变量初始化</h3><ol><li>定义于任何函数体之外的变量会被初始化为0；定义在函数体内部的内置类型变量将不被初始化，如果没有初始化，则其值为未定义；string类规定如果没有指定初始值则将会生成一个空串。</li></ol><h3 id="4-extern关键字"><a href="#4-extern关键字" class="headerlink" title="4.extern关键字"></a>4.extern关键字</h3><ol><li>变量声明规定了变量的类型和名字，使用extern关键字声明而不初始化则不是定义，不会申请内存空间， 而定义则会申请内存空间；</li><li>在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误；</li><li>任何包含了显示初始化的声明即成为了定义，如<code>extern double pi = 3.1416;</code>， 这么做也就抵消了extern的作用；</li><li>变量能且只能被定义一次，但是可以被声明多次；</li><li>如果要在多个文件中使用同一个变量，就必须将声明和定义分离，此时，定义必须出现且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，且绝对不能重复定义。</li></ol><h3 id="4-变量初始化顺序"><a href="#4-变量初始化顺序" class="headerlink" title="4.变量初始化顺序"></a>4.变量初始化顺序</h3><ol><li>基类的静态变量或成员变量；</li><li>派生类的静态变量或全局变量</li><li>基类的成员变量</li><li>派生类的成员变量</li></ol><ul><li>注意：</li></ul><ol><li>成员变量在使用初始化列表进行初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关；</li><li>如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关；</li><li>类中 const 成员常量必须在构造函数初始化列表中初始化；</li><li>类中 static 成员变量必须在类外初始化；</li></ol><h3 id="5-const和指针"><a href="#5-const和指针" class="headerlink" title="5.const和指针"></a>5.const和指针</h3><ol><li>指向常量的指针 <code>const int *p</code>: 指针指向的常量（对象）值不能改变；</li><li>常量指针 <code>int *const p</code>: 指针指向的地址不能改变，即指针只能指向该变量，不能指向别处；</li><li>指向常量的常量指针 <code>const int *const p</code>: 不论是指针所指向的对象的值，还是指针自己存储的地址值都不能被改变。</li></ol><h3 id="6-指针、常量和类型别名"><a href="#6-指针、常量和类型别名" class="headerlink" title="6.指针、常量和类型别名"></a>6.指针、常量和类型别名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> *pstring;<br><span class="hljs-type">const</span> pstring cstr = <span class="hljs-number">0</span>;     <span class="hljs-comment">// cstr 是指向char的常量指针</span><br><span class="hljs-type">const</span> pstring *ps;          <span class="hljs-comment">// ps是一个指针，它的对象是指向char的常量指针</span><br></code></pre></td></tr></table></figure><p>由于pstring实际上是指向char的指针，因此，const pstring就是指向char的常量指针，而非指向常量字符的指针<br><strong><code>const char *cstr = 0</code>, 这种理解是错误的，不能简单的将类型别名替换成它本来的样子。</strong></p><h3 id="7-静态数据成员与非静态数据成员的区别"><a href="#7-静态数据成员与非静态数据成员的区别" class="headerlink" title="7.静态数据成员与非静态数据成员的区别"></a>7.静态数据成员与非静态数据成员的区别</h3><ul><li>静态数据成员可以是不完全类型，可以说它所属的类类型；而非静态数据成员则受到限制，只能声明成它所属类的指针或引用</li><li>可以使用静态成员作为默认实参；非静态成员则不能，因为它的值本身属于对象的一部分；</li><li>静态成员处在所有对象之外</li></ul><h3 id="8-类的两项基本能力"><a href="#8-类的两项基本能力" class="headerlink" title="8.类的两项基本能力"></a>8.类的两项基本能力</h3><ul><li>数据抽象：定义数据成员和函数成员的能力；</li><li>封装：保护类的成员不被随意访问；设置为private</li></ul><h3 id="9-类可以将其他类或者函数设置为-友元，来赋予他们访问类的非公有成员的权限"><a href="#9-类可以将其他类或者函数设置为-友元，来赋予他们访问类的非公有成员的权限" class="headerlink" title="9.类可以将其他类或者函数设置为 友元，来赋予他们访问类的非公有成员的权限"></a>9.类可以将其他类或者函数设置为 友元，来赋予他们访问类的非公有成员的权限</h3><h3 id="10-构造函数应该使用构造函数初始值列表来初始化所有数据成员"><a href="#10-构造函数应该使用构造函数初始值列表来初始化所有数据成员" class="headerlink" title="10.构造函数应该使用构造函数初始值列表来初始化所有数据成员"></a>10.构造函数应该使用构造函数初始值列表来初始化所有数据成员</h3><h3 id="11-关于递增和递减运算符"><a href="#11-关于递增和递减运算符" class="headerlink" title="11.关于递增和递减运算符"></a>11.关于递增和递减运算符</h3><ul><li>前置版本：首先将运算对象加1（减1），然后将改变后的对象作为求值结果；</li><li>后置版本：将运算对象加1（减1），求值结果是运算对象改变之前那个值的副本；<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j;<br>j = ++i;    <span class="hljs-comment">// j = 1, i = 1; 前置版本得到递增之后的值</span><br>j = i++;    <span class="hljs-comment">// j = 1, i = 2; 后置版本得到递增之前的值</span><br></code></pre></td></tr></table></figure>由于后置版本需要将原始值存储下来，而前置版本则是直接返回递增后的值，因此建议优先考虑使用前置版本，从而避免后置版本的操作浪费。</li></ul><h3 id="12-static关键字"><a href="#12-static关键字" class="headerlink" title="12.static关键字"></a>12.static关键字</h3><p>static有两种用法：面向过程中的static 和 面向对象中的static</p><ol><li>面向过程中的static<br>静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区。自动变量一般会随着函数的退出而释放空间，静态数据（即使是函数内部的静态局部变量）也存放在全局数据区。全局数据区的数据并不会因为函数的退出而释放空间。<ul><li>静态全局变量：<ul><li>在全局数据区分配内存；</li><li>未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非被显式初始化）；</li><li>静态全局变量在声明它的整个文件都是可见的，而在该文件之外是不可见的；</li><li>其它文件中可以定义相同名字的变量，不会发生冲突；</li></ul></li><li>静态局部变量：<ul><li>在全局数据区分配内存；</li><li>在程序执行到该对象的声明处时被首次初始化，以后的函数调用不在进行初始化；</li><li>一般在声明处初始化，如果没有显示初始化，会被程序自动初始化为0；</li><li>始终驻留在全局数据区，直到程序运行结束，但其作用域是局部作用域，当定义其的函数或语句块结束时，作用域随之结束</li></ul></li><li>静态函数：<ul><li>在函数的返回类型前加上static关键字，即被定义为静态函数；</li><li>函数只能在声明它的文件当中可见，不能被其他文件使用；</li><li>其他文件中可以定义相同名字的函数，不会发生冲突；</li></ul></li></ul></li><li>面向对象中的static<ul><li>静态数据成员：<ul><li>对于非静态数据成员，每个类对象都有自己的一份拷贝，而静态数据成员被当作是类的成员，无论类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问；即静态数据成员是该类的所有对象所共有的，对于类的多个对象来说，静态数据成员只分配一次内存，其值对所有对象都是一样的，且值可以更新；</li><li>静态数据成员存储在全局数据区，定义时要分配空间，因此不能在类的声明中定义，而是在类中声明，但需要在类外进行定义；</li><li>和普通数据成员一样，遵循public, private, protected访问规则；</li><li>因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；</li><li>静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：<br> <code>＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞</code></li><li>类的静态数据成员有两种访问形式：<br> <code>＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞</code></li><li>静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省存储空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了；</li><li>同全局变量相比，使用静态数据成员有两个优势：<ol><li>静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；</li><li>可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；</li></ol></li></ul></li><li>静态成员函数<br> 与静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。静态成员函数与静态数据成员一样，都是类的内部实现，属于类定义的一部分。普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。如函数fn()实际上是this-&gt;fn()。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。<ul><li>出现在类体外的函数定义不能指定为static；</li><li>静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和静态成员函数；</li><li>非静态成员可以任意地访问静态成员函数和静态数据成员；</li><li>静态函数则不能访问非静态成员函数和非静态数据成员；</li><li>由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；</li><li>调用静态成员函数可以使用成员访问操作符(.)和(-&gt;)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式：<code>＜类名＞::＜静态成员函数名＞（＜参数表＞）</code>调用类的静态成员函数.</li></ul></li></ul></li></ol><h3 id="13-函数指针"><a href="#13-函数指针" class="headerlink" title="13.函数指针"></a>13.函数指针</h3><pre><code class="hljs"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fc</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-built_in">int</span> (*pt)(<span class="hljs-type">int</span>) = fc;<br><span class="hljs-comment">// 3种调用方式</span><br><span class="hljs-built_in">pt</span>(<span class="hljs-type">int</span>);<br>(*pt)(<span class="hljs-type">int</span>);<br>(pt)(<span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure></code></pre><h3 id="14-死锁、产生的必要条件、产生的原因、预防死锁"><a href="#14-死锁、产生的必要条件、产生的原因、预防死锁" class="headerlink" title="14.死锁、产生的必要条件、产生的原因、预防死锁"></a>14.死锁、产生的必要条件、产生的原因、预防死锁</h3><ol><li><p>死锁<br>两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。 </p></li><li><p>产生死锁的必要条件<br>虽然进程在运行过程中，可能发生死锁，但死锁的发生也必须具备一定的条件，死锁的发生必须具备以下四个必要条件： </p><ul><li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放； </li><li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放； </li><li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放； </li><li>环路等待条件：指在发生死锁时，必然存在一个[进程——资源]的环形链，即进程集合 {P0，P1，P2，···，Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，……，Pn 正在等待已被 P0 占用的资源。</li></ul></li><li><p>产生死锁的原因 </p><ul><li>竞争资源 </li><li>进程间推进顺序非法</li></ul></li><li><p>预防死锁 </p><ul><li>有序资源分配法<br> 这种算法资源按某种规则系统中的所有资源统一编号（例如打印机为1、磁带机为2、磁盘为3、等等），申请时必须以上升的次序。系统要求申请进程：<ol><li>对它所必须使用的而且属于同一类的所有资源，必须一次申请完；</li><li>在申请不同类资源时，必须按各类设备的编号依次申请。例如：进程PA，使用资源的顺序是R1，R2； 进程PB，使用资源的顺序是R2，R1；若采用动态分配有可能形成环路条件，造成死锁。</li></ol></li></ul><p> 采用有序资源分配法：R1的编号为1，R2的编号为2；</p><ul><li>PA：申请次序应是：R1，R2</li><li>PB：申请次序应是：R1，R2<br> 这样就破坏了环路条件，避免了死锁的发生</li><li>银行家算法<br> 银行家算法是避免死锁的一种重要方法。<br> 操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，<br> 如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。<br> 当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。<br> 若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。</li></ul></li></ol><h3 id="15-面向过程和面向对象"><a href="#15-面向过程和面向对象" class="headerlink" title="15.面向过程和面向对象"></a>15.面向过程和面向对象</h3><ol><li>面向过程：<br>面向过程是一种以事件为中心的编程思想，编程的时候把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。<br>优点：<br> - 流程化使得编程任务明确，在开发之前基本考虑了实现方式和最终结果，具体步骤清楚，便于节点分析。<br> - 效率高，面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序。<br> 缺点：<br> - 需要深入的思考，耗费精力，代码重用性低，扩展能力差，后期维护难度比较大。</li><li>面向对象：<br>面向对象是一种以“对象”为中心的编程思想，把要解决的问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个对象在整个解决问题的步骤中的属性和行为。<br>优点:<br> 1. 结构清晰，程序是模块化和结构化，更加符合人类的思维方式；<br> 2. 易扩展，代码重用率高，可继承，可覆盖，可以设计出低耦合的系统；<br> 3. 易维护，系统低耦合的特点有利于减少程序的后期维护工作量。<br> 缺点：<br> 1. 开销大，当要修改对象内部时，对象的属性不允许外部直接存取，所以要增加许多没有其他意义、只负责读或写的行为。这会为编程工作增加负担，增加运行开销，并且使程序显得臃肿。<br> 2. 性能低，由于面向更高的逻辑抽象层，使得面向对象在实现的时候，不得不做出性能上面的牺牲，计算时间和空间存储大小都开销很大。</li></ol><h3 id="16-进程通信的方式"><a href="#16-进程通信的方式" class="headerlink" title="16.进程通信的方式"></a>16.进程通信的方式</h3><p>管道、命名管道、信号、消息队列、共享内存、内存映射、信号量、Socket</p><ol><li>管道 管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，所有的 UNIX 系统都支持这种通信机制。管道本质其实是内核中维护的一块内存缓冲区，Linux 系统中通过 pipe() 函数创建管道，会生成两个文件描述符，分别对应管道的读端和写端。无名管道只能用于具有亲缘关系的进程间的通信。 </li><li>命名管道 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO），也叫命名管道、FIFO文件。有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO 的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。 </li><li>信号 信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。 </li><li>消息队列 消息队列就是一个消息的链表，可以把消息看作一个记录，具有特定的格式以及特定的优先级，对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程则可以从消息队列中读走消息，消息队列是随内核持续的。 </li><li>共享内存 共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会成为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。 </li><li>内存映射 内存映射（Memory-mapped I&#x2F;O）是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。 </li><li>信号量 信号量主要用来解决进程和线程间并发执行时的同步问题，进程同步是并发进程为了完成共同任务采用某个条件来协调它们的活动。对信号量的操作分为 P 操作和 V 操作，P 操作是将信号量的值减 1，V 操作是将信号量的值加 1。当信号量的值小于等于 0 之后，再进行 P 操作时，当前进程或线程会被阻塞，直到另一个进程或线程执行了 V 操作将信号量的值增加到大于 0 之时。 </li><li>Socket 套接字（Socket），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。Socket 一般用于网络中不同主机上的进程之间的通信。</li></ol><h3 id="17-进程和线程的区别"><a href="#17-进程和线程的区别" class="headerlink" title="17.进程和线程的区别"></a>17.进程和线程的区别</h3><ol><li>进程是操作系统进行资源调度和分配的基本单位,线程是操作系统可执行的最小调度和分配单位 </li><li>一个线程属于一个进程,一个进程可以有多个线程 </li><li>一个进程崩溃不影响其他进程,但是一个线程崩溃会让进程崩溃 </li><li>进程在执行过程中有独立的存储单元,而线程之间共享进程的内存 </li><li>进程之间切换系统开销大,而线程之间切换开销比进程小</li></ol><hr><ol><li>进程有独立的地址空间，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间； </li><li>进程和线程切换时，需要切换进程和线程的上下文，进程的上下文切换时间开销远远大于线程上下文切换时间，耗费资源较大，效率要差一些； </li><li>进程的并发性较低，线程的并发性较高； </li><li>每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制； </li><li>系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了 CPU 外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源； </li><li>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li></ol><hr><p>协程：<br>是一种比线程更加轻量级的存在。一个线程也可以拥有多个协程。其执行过程更类似于子例程，或者说不带返回值的函数调用。</p><h3 id="18-volatile关键字"><a href="#18-volatile关键字" class="headerlink" title="18.volatile关键字"></a>18.volatile关键字</h3><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：<code>volatile int vInt</code>; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a = i;<br>...<br><span class="hljs-comment">// 其他代码，并未明确告诉编译器，对 i 进行过操作</span><br><span class="hljs-type">int</span> b = i;<br></code></pre></td></tr></table></figure><p>volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。而优化做法是，由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i是一个寄存器变量或者表示一个端口数据就容易出错，所以说 volatile 可以保证对特殊地址的稳定访问。\</p><h3 id="19-内联函数"><a href="#19-内联函数" class="headerlink" title="19.内联函数"></a>19.内联函数</h3><ol><li>内联函数的函数体内不能含有复杂的结构控制语句，如switch和while，否则编译器将该函数视同普通函数那样产生函数调用代码。</li><li>递归函数不能被用来作为内联函数。</li><li>内联函数一般适合于只有1-5行语句的小函数，对于一个含有很多语句的大函数，没必要使用内联函数来实现。</li><li>内联函数的定义必须出现在内联函数第一次被调用之前。</li><li>对内联函数不能进行异常接口声明，就是不能声明可能抛出的异常。</li><li>在类中声明和定义的函数默认是隐式内联的，如果在类中声明，在类外定义，希望内联时，类外定义需要显式的使用inline。</li></ol><h3 id="20-C-强制类型转换：static-cast、dynamic-cast、const-cast、reinterpret-cast"><a href="#20-C-强制类型转换：static-cast、dynamic-cast、const-cast、reinterpret-cast" class="headerlink" title="20.C++强制类型转换：static_cast、dynamic_cast、const_cast、reinterpret_cast"></a>20.<a href="https://www.cnblogs.com/chenyangchun/p/6795923.html">C++强制类型转换：static_cast、dynamic_cast、const_cast、reinterpret_cast</a></h3><ol><li>c语言强制类型转换主要用于基础的数据类型间的转换，语法为：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(type-id)expression<span class="hljs-comment">//转换格式1</span><br>type-<span class="hljs-built_in">id</span>(expression)<span class="hljs-comment">//转换格式2</span><br></code></pre></td></tr></table></figure></li><li>c++除了能使用c语言的强制类型转换外，还新增了四种强制类型转换：static_cast、dynamic_cast、const_cast、reinterpret_cast，主要运用于继承关系类间的强制转化，语法为：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">static_cast</span>&lt;new_type&gt;      (expression)<br><span class="hljs-built_in">dynamic_cast</span>&lt;new_type&gt;     (expression) <br><span class="hljs-built_in">const_cast</span>&lt;new_type&gt;       (expression) <br><span class="hljs-built_in">reinterpret_cast</span>&lt;new_type&gt; (expression)<br></code></pre></td></tr></table></figure>备注：new_type为目标数据类型，expression为原始数据类型变量或者表达式。</li></ol><ul><li>dynamic_cast将一个基类对象指针（或引用）cast到继承类指针，dynamic_cast会根据基类指针是否真正指向继承类指针来做相应处理， 即会作一定的判断。 对指针进行dynamic_cast，失败返回null，成功返回正常cast后的对象指针； 对引用进行dynamic_cast，失败抛出一个异常std::bad_cast，成功返回正常cast后的对象引用。 </li><li>reinterpret_cast这个转换是最“不安全”的，两个没有任何关系的类指针之间转换都可以用这个转换实现。</li><li>static_cast静态转换是最接近于C风格转换，很多时候都需要程序员自身去判断转换是否安全。</li><li>const_cast这个转换好理解，可以将常量转成非常量。</li></ul><h3 id="21-运算符优先级"><a href="#21-运算符优先级" class="headerlink" title="21.运算符优先级"></a>21.运算符优先级</h3><p>赋值运算符 &lt; 逻辑运算符 &lt; 关系运算符 &lt; 算术运算符</p><h3 id="22-可以用于字符串拷贝的函数memcpy-strcpy-strcmp-strstr-sprintf"><a href="#22-可以用于字符串拷贝的函数memcpy-strcpy-strcmp-strstr-sprintf" class="headerlink" title="22.可以用于字符串拷贝的函数memcpy(), strcpy(), strcmp(), strstr(), sprintf()"></a>22.可以用于字符串拷贝的函数memcpy(), strcpy(), strcmp(), strstr(), sprintf()</h3><ul><li>memcpy()函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">从数组a复制k个元素到数组b中：<span class="hljs-built_in">memcpy</span>(b,a,<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>/<span class="hljs-type">double</span>)*k)<br>数组a全部复制到数组b中：<span class="hljs-built_in">memcpy</span>(b,a,<span class="hljs-built_in">sizeof</span>(a))<br></code></pre></td></tr></table></figure></li><li>strcpy()函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">strcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> *destin, <span class="hljs-type">char</span> *source)</span></span>;<br>功能：将source指向的字符串拷到destin，会覆盖之前的，source包含<span class="hljs-string">&#x27;\0&#x27;</span><br></code></pre></td></tr></table></figure></li><li>strcmp()函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strcmp</span><span class="hljs-params">(<span class="hljs-type">char</span> * str1,<span class="hljs-type">char</span> * str2)</span></span>; <br>功能: 比较两个字符串str1,str2<br>返回: str1&lt;str2,返回负数;str1=str2,返回 <span class="hljs-number">0</span>;str1&gt;str2,返回正数,,按位比较<br></code></pre></td></tr></table></figure></li><li>strstr()函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">strstr</span><span class="hljs-params">(<span class="hljs-type">char</span>* str1,<span class="hljs-type">char</span>* str2)</span></span>;<br>功能:找出str2字符串在str1字符串中第一次出现的位置(不包括str2的串结束符) <br>返回: 返回该位置的指针,如找不到,返回空指针<br><span class="hljs-type">char</span> b[<span class="hljs-number">20</span>]=<span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;position:%s\n&quot;</span>,<span class="hljs-built_in">strstr</span>(b,<span class="hljs-string">&quot;bc&quot;</span>));  <span class="hljs-comment">//position:bcdef</span><br></code></pre></td></tr></table></figure></li><li>sprintf()函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">把信息输出到字符串，保证字符串足够大 <br><span class="hljs-type">char</span> a[<span class="hljs-number">20</span>]; <br><span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a)); <br><span class="hljs-built_in">sprintf</span>(a,<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>); <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">sizeof</span>(a);i++)&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>&#125;<br><span class="hljs-comment">//输出20位 52 53 54 55 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br><span class="hljs-built_in">puts</span>(a)<br><span class="hljs-comment">// 输出4567</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="23-静态链接和动态链接"><a href="#23-静态链接和动态链接" class="headerlink" title="23.静态链接和动态链接"></a>23.静态链接和动态链接</h3><ul><li>静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。</li><li>动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。</li></ul><h3 id="24-内存对齐"><a href="#24-内存对齐" class="headerlink" title="24.内存对齐"></a>24.内存对齐</h3><ol><li>为何需要内存对齐？<br>现代计算机中内存空间都是按照字节(byte)进行划分的，所以从理论上讲对于任何类型的变量访问都可以从任意地址开始，但是在实际情况中，在访问特定类型变量的时候经常在特定的内存地址访问，所以这就需要把各种类型数据按照一定的规则在空间上排列，而不是按照顺序一个接一个的排放，这种就称为内存对齐，内存对齐是指首地址对齐，而不是说每个变量大小对齐。</li><li>内存对齐的原则<ol><li>结构体变量的首地址能够被其最宽基本类型成员的大小所整除；</li><li>结构体每个成员相对于结构体首地址的偏移量都是当前成员大小的整数倍，如有需要编译器会在成员之间加上填充字节；</li><li>结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。<br>说明：</li><li>基本类型是指前面提到的像char、short、int、float、double这样的内置数据类型；</li><li>对于复合数据类型，如结构体嵌套结构体，那么基本类型是指前面提到的像char、short、int、float、double这样的内置数据类型；</li><li>我认为计算结构体大小的时候，主要用到准则2和准则3，对于准则1是编译器自动完成的，不需要过多理会。</li><li>C++中类的可以看做是特殊的结构体，所以类的sizeof的计算和结构体是一样的。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 如果以最长20字节为准，内部double占8字节，</span><br><span class="hljs-comment">这段内存的地址0x00000020并不是double的整数倍，</span><br><span class="hljs-comment">只有当最小为0x00000024时可以满足整除double（8Byte）同时又可以容纳int a[5]的大小，</span><br><span class="hljs-comment">所以正确的结果应该是result=24 */</span>  <br><span class="hljs-keyword">union</span> <span class="hljs-title class_">example</span> &#123;    <span class="hljs-type">int</span> a[<span class="hljs-number">5</span>];    <span class="hljs-type">char</span> b;    <span class="hljs-type">double</span> c;   &#125;;   <br><span class="hljs-type">int</span> result = <span class="hljs-built_in">sizeof</span>(example);<br>cout&lt;&lt;result&lt;&lt;endl;     <span class="hljs-comment">// 24</span><br><br><span class="hljs-comment">/* 如果我们不考虑字节对齐，那么内存地址0x0021不是double（8Byte）的整数倍，</span><br><span class="hljs-comment">所以需要字节对齐，那么此时满足是double（8Byte）的整数倍的最小整数是0x0024，</span><br><span class="hljs-comment">说明此时char b对齐int扩充了三个字节。所以最后的结果是result=32 */</span>  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">example</span> &#123;    <span class="hljs-type">int</span> a[<span class="hljs-number">5</span>];    <span class="hljs-type">char</span> b;    <span class="hljs-type">double</span> c;   &#125;test_struct; <br><span class="hljs-type">int</span> result = <span class="hljs-built_in">sizeof</span>(test_struct); <br>cout&lt;&lt;result&lt;&lt;endl;     <span class="hljs-comment">// 32</span><br><br><span class="hljs-comment">/* 字节对齐除了内存起始地址要是数据类型的整数倍以外，还要满足一个条件，</span><br><span class="hljs-comment">那就是占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍，</span><br><span class="hljs-comment">所以20不是double（8Byte）的整数倍，我们还要扩充四个字节，最后的结果是result=24 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">example</span> &#123;    <span class="hljs-type">char</span> b;    <span class="hljs-type">double</span> c;    <span class="hljs-type">int</span> a;   &#125;test_struct;   <br><span class="hljs-type">int</span> result = <span class="hljs-built_in">sizeof</span>(test_struct);   <br>cout&lt;&lt;result&lt;&lt;endl;     <span class="hljs-comment">// 24</span><br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="25-深拷贝和浅拷贝"><a href="#25-深拷贝和浅拷贝" class="headerlink" title="25.深拷贝和浅拷贝"></a>25.深拷贝和浅拷贝</h3><ul><li>浅拷贝（默认拷贝函数）：将原对象或原数组的引用直接赋给新对象，新数组，新对象&#x2F;新数组只是原对象的一个引用。</li><li>深拷贝：创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是引用。深拷贝会在堆内存中另外申请空间来储存数据，从而解决了指针悬挂问题。当数据成员中有指针时，必须要用深拷贝。</li></ul><ol><li>在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。</li><li>深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。<br>（1）如果拷贝的对象里的元素只有值，没有引用，那么深拷贝与浅拷贝是相同的。都会对原有对象复制一份，产生一个新对象，对新对象里的值进行修改不会影响原有对象，新对象与原对象完全分离开。<br>（2）如果拷贝的对象里的元素包含引用（像一个列表中储存着另一个列表，存的就是另一个列表的引用），那么浅拷贝和深拷贝是不同的。浅拷贝虽然将原有对象复制一份，但是依然保存的是引用，所以对新对象里的引用里的值进行修改，依然会改变原对象里的列表的值，新对象与原对象并没有完全分离开。深拷贝不同，它会将原对象里的引用也新创建一个，即新建一个列表，然后放的是新列表的引用，这样就可以将新对象和原对象完全分开。<br>(3)有指针时，必须用深拷贝当数据成员中含有指针时，必须用深拷贝当用浅拷贝时，新对象的指针与原对象的指针指向了堆上的同一块儿内存，新对象和原对象析构时，新对象先把其指向的动态分配的内存释放了一次，而后原对象析构时又将这块已经释放过的内存再释放一次。对同一块动态内存执行2次以上释放的结果是未定义的，所有会导致内存泄漏或程序崩溃。所以需要深拷贝来解决问题，当拷贝对象中有对其他资源（如堆、文件、系统等）的引用时（引用可以是指针或引用）时，对象开辟一块新的资源，而不再对拷贝对象中对其他资源的引用的指针或引用进行单纯的赋值。</li></ol><h3 id="26-类继承时，派生类对不同关键字修饰的基类方法的访问权限"><a href="#26-类继承时，派生类对不同关键字修饰的基类方法的访问权限" class="headerlink" title="26.类继承时，派生类对不同关键字修饰的基类方法的访问权限"></a>26.类继承时，派生类对不同关键字修饰的基类方法的访问权限</h3><p>类中的成员可以分为三种类型，分别为private成员、protected成员、public成员。类中可以直接访问自己类的public、protected、private成员，但类对象只能访问自己类的public成员。</p><ol><li>public继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象可以访问基类的public成员，不可以访问基类的protected、private成员。</li><li>protected继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象不可以访问基类的public、protected、private成员。</li><li>private继承：派生类可以访问基类的public、protected成员，不可以访问基类的private成员； 派生类对象不可以访问基类的public、protected、private成员。</li></ol><h3 id="26-C-类内可以定义引用数据成员吗？"><a href="#26-C-类内可以定义引用数据成员吗？" class="headerlink" title="26.C++ 类内可以定义引用数据成员吗？"></a>26.C++ 类内可以定义引用数据成员吗？</h3><p>c++类内可以定义引用成员变量，但要遵循以下三个规则：</p><ol><li>不能用默认构造函数初始化，必须提供构造函数来初始化引用成员变量。否则会造成引用未初始化错误。</li><li>构造函数的形参也必须是引用类型。</li><li>不能在构造函数里初始化，必须在初始化列表中进行初始化。</li></ol><h3 id="27-构造函数为什么不能被声明为虚函数？"><a href="#27-构造函数为什么不能被声明为虚函数？" class="headerlink" title="27.构造函数为什么不能被声明为虚函数？"></a>27.构造函数为什么不能被声明为虚函数？</h3><ol><li>从存储空间角度：虚函数对应一个虚函数表,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，如何调用。（悖论）</li><li>从使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</li><li>从实现上看，虚函数表在构造函数调用后才建立，因而构造函数不可能成为虚函数。从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。</li></ol><h3 id="28-简述一下什么是常函数-const函数-，有什么作用"><a href="#28-简述一下什么是常函数-const函数-，有什么作用" class="headerlink" title="28. 简述一下什么是常函数(const函数)，有什么作用"></a>28. 简述一下什么是常函数(const函数)，有什么作用</h3><p>类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加const，而对于改变数据成员的成员函数不能加 const。所以 const 关键字对成员函数的行为作了更明确的限定：有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；没有 const 修饰的成员函数，对数据成员则是可读可写的。除此之外，在类的成员函数后面加 const 还有什么好处呢？那就是常量（即 const）对象可以调用 const 成员函数，而不能调用非const修饰的函数。正如非const类型的数据可以给const类型的变量赋值一样，反之则不成立。</p><h3 id="29-虚继承"><a href="#29-虚继承" class="headerlink" title="29. 虚继承"></a>29. <a href="url=https://zhuanlan.zhihu.com/p/35158136">虚继承</a></h3><p>虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。虚继承可以解决多种继承前面提到的两个问题.<br>虚继承使派生类除了继承基类成员作为自己的成员之外，内部还会有一份内存来保存哪些是基类的成员。当final_derived继承derived1和derived2之后，编译器根据虚继承多出来的内存，查到derived1和derived2拥有共同的基类的成员，就不会从derived1和derived2中继承这些，而是直接从共同的基类中继承成员，也就是说，final_derived直接继承base的成员，然后再继承derived1和derived2各自新增的成员。</p><h3 id="30-简述一下虚函数和纯虚函数，以及实现原理"><a href="#30-简述一下虚函数和纯虚函数，以及实现原理" class="headerlink" title="30. 简述一下虚函数和纯虚函数，以及实现原理"></a>30. 简述一下虚函数和纯虚函数，以及实现原理</h3><ol><li>C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。如果调用非虚函数，则无论实际对象是什么类型，都执行基类类型所定义的函数。非虚函数总是在编译时根据调用该函数的对象，引用或指针的类型而确定。如果调用虚函数，则直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定或指针所指向的对象所属类型定义的版本。虚函数必须是基类的非静态成员函数。虚函数的作用是实现动态联编，也就是在程序的运行阶段动态地选择合适的成员函数，在定义了虚函数后，可以在基类的派生类中对虚函数重新定义，在派生类中重新定义的函数应与虚函数具有相同的形参个数和形参类型。以实现统一的接口，不同定义过程。如果在派生类中没有对虚函数重新定义，则它继承其基类的虚函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">//虚函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">GetName</span><span class="hljs-params">()</span></span>&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;PersonName:xiaosi&quot;</span>&lt;&lt;endl;<br>        &#125;;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<span class="hljs-keyword">public</span> Person&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetName</span><span class="hljs-params">()</span></span>&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;StudentName:xiaosi&quot;</span>&lt;&lt;endl;<br>        &#125;;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//指针</span><br>    Person *person = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Student</span>();<br>    <span class="hljs-comment">//基类调用子类的函数</span><br>    person-&gt;<span class="hljs-built_in">GetName</span>();<span class="hljs-comment">//StudentName:xiaosi</span><br>&#125;<br></code></pre></td></tr></table></figure>虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。</li><li>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“&#x3D;0” <code>virtualvoid GetName() =0</code>。在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。为了解决上述问题，将函数定义为纯虚函数，则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。将函数定义为纯虚函数能够说明，该函数为后代类型提供了可以覆盖的接口，但是这个类中的函数绝不会调用。声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。必须在继承类中重新声明函数（不要后面的＝0）否则该派生类也不能实例化，而且它们在抽象类中往往没有定义。定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>   <span class="hljs-keyword">public</span>:<br>      <span class="hljs-comment">//纯虚函数</span><br>      <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">GetName</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<span class="hljs-keyword">public</span> Person&#123;<br>   <span class="hljs-keyword">public</span>:<br>      <span class="hljs-built_in">Student</span>()&#123;<br>      &#125;;<br>      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetName</span><span class="hljs-params">()</span></span>&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;StudentName:xiaosi&quot;</span>&lt;&lt;endl;<br>      &#125;;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   Student student;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="31-说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？"><a href="#31-说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？" class="headerlink" title="31. 说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？"></a>31. 说说纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？</h3><ol><li>纯虚函数不可以实例化，但是可以用其派生类实例化，</li><li>虚函数的原理采用 vtable。类中含有纯虚函数时，其vtable 不完全，有个空位。即“纯虚函数在类的vftable表中对应的表项被赋值为0。也就是指向一个不存在的函数。由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象。在它的派生类中，除非重写此函数，否则也不能生成对象。”所以纯虚函数不能实例化。</li><li>纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。</li><li>定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</li></ol><h3 id="31-虚函数与纯虚函数的区别"><a href="#31-虚函数与纯虚函数的区别" class="headerlink" title="31.虚函数与纯虚函数的区别"></a>31.虚函数与纯虚函数的区别</h3><ol><li>虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。</li><li>虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。</li><li>虚函数和纯虚函数都可以在子类中被重写，以多态的形式被调用。</li><li>虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重写，目的是提供一个统一的接口。</li><li>虚函数的定义形式：virtual{};纯虚函数的定义形式：virtual { } &#x3D; 0;在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。</li></ol><h3 id="32-构造函数中能不能调用虚方法"><a href="#32-构造函数中能不能调用虚方法" class="headerlink" title="32.构造函数中能不能调用虚方法"></a>32.构造函数中能不能调用虚方法</h3><p>不要在构造函数中调用虚方法，从语法上讲，调用完全没有问题，但是从效果上看，往往不能达到需要的目的。<br>派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。<br>同样，进入基类析构函数时，对象也是基类类型。<br>所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。</p><h3 id="33-拷贝构造函数的参数是什么传递方式，为什么"><a href="#33-拷贝构造函数的参数是什么传递方式，为什么" class="headerlink" title="33.拷贝构造函数的参数是什么传递方式，为什么"></a>33.拷贝构造函数的参数是什么传递方式，为什么</h3><p><strong>拷贝构造函数的参数必须使用引用传递</strong><br>如果拷贝构造函数中的参数不是一个引用，即形如<code>CClass(const CClass c_class)</code>，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。<br>需要澄清的是，传指针其实也是传值，如果上面的拷贝构造函数写成<code>CClass(const CClass* c_class)</code>，也是不行的。事实上，只有传引用不是传值外，其他所有的传递方式都是传值。</p><h3 id="34-抽象类"><a href="#34-抽象类" class="headerlink" title="34.抽象类"></a>34.抽象类</h3><p>抽象类的定义如下：</p><ol><li>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“&#x3D;0”，有虚函数的类就叫做抽象类。</li><li>抽象类有如下几个特点：<br>1）抽象类只能用作其他类的基类，不能建立抽象类对象。<br>2）抽象类不能用作参数类型、函数返回类型或显式转换的类型。<br>3）可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态性。</li></ol><h3 id="35-虚析构函数，什么作用"><a href="#35-虚析构函数，什么作用" class="headerlink" title="35.虚析构函数，什么作用"></a>35.虚析构函数，什么作用</h3><p>虚析构函数，是将基类的析构函数声明为virtual，举例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeKeeper</span><br>&#123;<br><span class="hljs-keyword">public</span>:    <br>    <span class="hljs-built_in">TimeKeeper</span>() &#123;&#125;        <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">TimeKeeper</span>() &#123;&#125;    <br>&#125;;<br></code></pre></td></tr></table></figure><p>总的来说虚析构函数是为了避免内存泄露，而且是当子类中会有指针成员变量时才会使用得到的。也就说虚析构函数使得在删除指向子类对象的基类指针时可以调用子类的析构函数达到释放子类中堆内存的目的，而防止内存泄露的.<br>定义一个基类的指针p，在delete p时，如果基类的析构函数是虚函数，这时只会看p所赋值的对象，如果p赋值的对象是派生类的对象，就会调用派生类的析构函数（毫无疑问，在这之前也会先调用基类的构造函数，在调用派生类的构造函数，然后调用派生类的析构函数，基类的析构函数，所谓先构造的后释放）；如果p赋值的对象是基类的对象，就会调用基类的析构函数，这样就不会造成内存泄露。<br>如果基类的析构函数不是虚函数，在delete p时，调用析构函数时，只会看指针的数据类型，而不会去看赋值的对象，这样就会造成内存泄露。<br>总结一下虚析构函数的作用： </p><ol><li>如果父类的析构函数不加virtual关键字<br>当父类的析构函数不声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，只调动父类的析构函数，而不调动子类的析构函数。 </li><li>如果父类的析构函数加virtual关键字<br>当父类的析构函数声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，先调动子类的析构函数，再调动父类的析构函数。<br><strong>父类的构造函数和析构函数是子类无法继承的，也就是说每一个类都有自己独有的构造函数和析构函数</strong></li></ol><h3 id="36-简述一下拷贝赋值和移动赋值？"><a href="#36-简述一下拷贝赋值和移动赋值？" class="headerlink" title="36.简述一下拷贝赋值和移动赋值？"></a>36.简述一下拷贝赋值和移动赋值？</h3><p>拷贝赋值是通过拷贝构造函数来赋值，在创建对象时，使用同一类中之前创建的对象来初始化新创建的对象。<br>移动赋值是通过移动构造函数来赋值，二者的主要区别在于</p><ol><li>拷贝构造函数的形参是一个左值引用，而移动构造函数的形参是一个右值引用；</li><li>拷贝构造函数完成的是整个对象或变量的拷贝，而移动构造函数是生成一个指针指向源对象或变量的地址，接管源对象的内存，相对于大量数据的拷贝节省时间和内存空间。</li></ol><h3 id="37-仿函数了解吗？有什么作用"><a href="#37-仿函数了解吗？有什么作用" class="headerlink" title="37. 仿函数了解吗？有什么作用"></a>37. 仿函数了解吗？有什么作用</h3><p>仿函数（functor）又称为函数对象（function object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载operator()运算符(函数调用运算符，即()括号运算符)，举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Func</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str)</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout&lt;&lt;str&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br>Func myFunc;<br><span class="hljs-built_in">myFunc</span>(<span class="hljs-string">&quot;helloworld!&quot;</span>);<br><br>&gt;&gt;&gt;helloworld!<br></code></pre></td></tr></table></figure><h3 id="38-C-中哪些函数不能被声明为虚函数？"><a href="#38-C-中哪些函数不能被声明为虚函数？" class="headerlink" title="38.C++ 中哪些函数不能被声明为虚函数？"></a>38.C++ 中哪些函数不能被声明为虚函数？</h3><p>常见的不不能声明为虚函数的有：普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数。</p><ol><li>为什么C++不支持普通函数为虚函数？<br>普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。</li><li>为什么C++不支持构造函数为虚函数？<br>这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）<br>构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数</li><li>为什么C++不支持内联成员函数为虚函数？<br>其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数）<br>内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数</li><li>为什么C++不支持静态成员函数为虚函数？<br>这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。<br>静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别</li><li>为什么C++不支持友元函数为虚函数？<br>因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。</li></ol><h3 id="39-C-中类模板和模板类的区别"><a href="#39-C-中类模板和模板类的区别" class="headerlink" title="39.  C++ 中类模板和模板类的区别"></a>39.  C++ 中类模板和模板类的区别</h3><ol><li>类模板是模板的定义，不是一个实实在在的类，定义中用到通用类型参数</li><li>模板类是实实在在的类定义，是<strong>类模板的实例化</strong>。在类定义中参数被实际类型所代替。<br>所谓类模板，实际上是建立一个通用类，其数据成员、成员函数的返回值类型和形参类型不具体指定，用一个虚拟的类型来代表。使用类模板定义对象时，系统会用实参的类型来取代类模板中虚拟类型从而实现了不同类的功能。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> 类型参数&gt;<br><span class="hljs-keyword">class</span> 类名&#123;<br>       类成员声明 <br>&#125;;<br><br>或者<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> 类型参数&gt;<br><span class="hljs-keyword">class</span> 类名&#123;<br>       类成员声明 <br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h3 id="40-虚函数表里存放的内容是什么时候写进去的？"><a href="#40-虚函数表里存放的内容是什么时候写进去的？" class="headerlink" title="40. 虚函数表里存放的内容是什么时候写进去的？"></a>40. <a href="url=https://blog.csdn.net/ThinPikachu/article/details/104481011">虚函数表里存放的内容是什么时候写进去的？</a></h3><ol><li>虚函数表是一个存储虚函数地址的数组,以NULL结尾。虚表（vftable）在编译阶段生成，对象内存空间开辟以后，写入对象中的 vfptr，然后调用构造函数。即：虚表在构造函数之前写入</li><li>除了在构造函数之前写入之外，我们还需要考虑到虚表的二次写入机制，通过此机制让每个对象的虚表指针都能准确的指向到自己类的虚表，为实现动多态提供支持。所谓的虚表的二次写入指的是在继承关系中，派生类对象要调用两次构造函数，一次是基类的，另外一次是自己的，因此虚表要写入两次。<ul><li>首先是在编译间段生成基类和派生类的虚函数表，注意，其实这里的派生类虚表不是真正的派生类的虚表，最终的派生类的虚表是派生类虚表和基类虚表合并以后的产物。</li><li>接着是派生类对象首先给从基类中继承下来的成员开辟内存，接着在调用基类的构造函数之前指向基类的虚表，</li><li>接下来调用基类的构造函数，将基类的成员全部赋值为0，即将基类的vfptr指向NULL</li><li>接着是派生类对象为自己的成员开辟内存</li><li>接着在调用派生类的构造函数之前将vfptr指向派生类的虚表，在这之前，要进行虚表合并，生成派生类最终的虚函数表</li><li>接着在调用派生类的构造函数之前，将派生类的虚函数指针指向派生类的最终虚函数表</li><li>最后进行虚函数指针的合并，由外向内合并</li></ul></li></ol><h3 id="41-迭代器用过吗？什么时候会失效？"><a href="#41-迭代器用过吗？什么时候会失效？" class="headerlink" title="41.迭代器用过吗？什么时候会失效？"></a>41.迭代器用过吗？什么时候会失效？</h3><p>常用容器迭代器失效情形如下。</p><ol><li>对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。</li><li>对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。</li><li>对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。</li></ol><h3 id="42-说一下STL中迭代器的作用，有指针为何还要迭代器？"><a href="#42-说一下STL中迭代器的作用，有指针为何还要迭代器？" class="headerlink" title="42. 说一下STL中迭代器的作用，有指针为何还要迭代器？"></a>42. 说一下STL中迭代器的作用，有指针为何还要迭代器？</h3><p>Iterator（迭代器）模式又称游标（Cursor）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。 由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展Iterator。</p><ol><li>迭代器的作用<br>（1）用于指向顺序容器和关联容器中的元素<br>（2）通过迭代器可以读取它指向的元素<br>（3）通过非const迭代器还可以修改其指向的元素</li><li>迭代器和指针的区别<ol><li>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，重载了指针的一些操作符，–&gt;、++、–等。迭代器封装了指针，是一个”可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象，本质是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</li><li>迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。</li></ol></li><li>迭代器产生的原因<br>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</li></ol><h3 id="43-说说-STL-中-resize-和-reserve-的区别"><a href="#43-说说-STL-中-resize-和-reserve-的区别" class="headerlink" title="43.说说 STL 中 resize 和 reserve 的区别"></a>43.说说 STL 中 resize 和 reserve 的区别</h3><ol><li>首先必须弄清楚两个概念：<br>（1）capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素的个数。还不能通过下标等访问，因为此时容器中还没有创建任何对象。<br>（2）size：指的是此时容器中实际的元素个数。可以通过下标访问0-(size-1)范围内的对象。</li><li>resize和reserve区别主要有以下几点：<br>（1）resize既分配了空间，也创建了对象；reserve表示容器预留空间，但并不是真正的创建对象，需要通过insert（）或push_back（）等创建对象。<br>（2）resize既修改capacity大小，也修改size大小；reserve只修改capacity大小，不修改size大小。<br>（3）两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值（默认为0）；reserve只带一个参数，表示容器预留的大小。</li><li>问题延伸：<ul><li><p>resize 和 reserve 既有差别，也有共同点。两个接口的共同点是它们都保证了vector的空间大小(capacity)最少达到它的参数所指定的大小。下面就他们的细节进行分析。</p></li><li><p>为实现resize的语义，resize接口做了两个保证：<br>  （1）保证区间[0, new_size)范围内数据有效，如果下标index在此区间内，vector[indext]是合法的；</p><p>  （2）保证区间[0, new_size)范围以外数据无效，如果下标index在区间外，vector[indext]是非法的。</p></li><li><p>reserve只是保证vector的空间大小(capacity)最少达到它的参数所指定的大小n。在区间[0, n)范围内，如果下标是index，vector[index]这种访问有可能是合法的，也有可能是非法的，视具体情况而定。<br> 以下是两个接口的源代码：</p></li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(size_type new_size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">resize</span>(new_size, <span class="hljs-built_in">T</span>());<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(size_type new_size, <span class="hljs-type">const</span> T &amp;x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (new_size &lt; <span class="hljs-built_in">size</span>())<br>        <span class="hljs-built_in">erase</span>(<span class="hljs-built_in">begin</span>() + new_size, <span class="hljs-built_in">end</span>()); <span class="hljs-comment">// erase区间范围以外的数据，确保区间以外的数据无效</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">insert</span>(<span class="hljs-built_in">end</span>(), new_size - <span class="hljs-built_in">size</span>(), x); <span class="hljs-comment">// 填补区间范围内空缺的数据，确保区间内的数据有效</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; a;<br>    cout &lt;&lt; <span class="hljs-string">&quot;initial capacity:&quot;</span> &lt;&lt; a.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;initial size:&quot;</span> &lt;&lt; a.<span class="hljs-built_in">size</span>() &lt;&lt; endl; <span class="hljs-comment">/*resize改变capacity和size*/</span><br>    a.<span class="hljs-built_in">resize</span>(<span class="hljs-number">20</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;resize capacity:&quot;</span> &lt;&lt; a.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;resize size:&quot;</span> &lt;&lt; a.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    vector&lt;<span class="hljs-type">int</span>&gt; b; <span class="hljs-comment">/*reserve改变capacity,不改变resize*/</span><br>    b.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;reserve capacity:&quot;</span> &lt;&lt; b.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;reserve size:&quot;</span> &lt;&lt; b.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*      </span><br><span class="hljs-comment">运行结果：   </span><br><span class="hljs-comment">initial capacity:0  </span><br><span class="hljs-comment">initial size:0  </span><br><span class="hljs-comment">resize capacity:20  </span><br><span class="hljs-comment">resize size:20  </span><br><span class="hljs-comment">reserve capacity:100  </span><br><span class="hljs-comment">reserve size:0 </span><br><span class="hljs-comment">*/</span> <br></code></pre></td></tr></table></figure><p>注意：如果n大于当前的vector的容量(是容量，并非vector的size)，将会引起自动内存分配。所以现有的pointer,references,iterators将会失效。而内存的重新配置会很耗时间。</p><h3 id="44-STL-容器动态链接可能产生的问题？"><a href="#44-STL-容器动态链接可能产生的问题？" class="headerlink" title="44.STL 容器动态链接可能产生的问题？"></a>44.STL 容器动态链接可能产生的问题？</h3><ol><li>可能产生的问题<br> 容器是一种动态分配内存空间的一个变量集合类型变量。在一般的程序函数里，局部容器，参数传递容器，参数传递容器的引用，参数传递容器指针都是可以正常运行的，而在动态链接库函数内部使用容器也是没有问题的，但是给动态库函数传递容器的对象本身，则会出现内存堆栈破坏的问题。</li><li>产生问题的原因<br>容器和动态链接库相互支持不够好，动态链接库函数中使用容器时，参数中只能传递容器的引用，并且要保证容器的大小不能超出初始大小，否则导致容器自动重新分配，就会出现内存堆栈破坏问题。</li></ol><h3 id="45-说说-map-和-unordered-map-的区别？底层实现"><a href="#45-说说-map-和-unordered-map-的区别？底层实现" class="headerlink" title="45. 说说 map 和 unordered_map 的区别？底层实现"></a>45. 说说 map 和 unordered_map 的区别？底层实现</h3><p>map和unordered_map的区别在于他们的实现基理不同。</p><ol><li>map实现机理<br> map内部实现了一个红黑树（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。</li><li>unordered_map实现机理<br>unordered_map内部实现了一个哈希表（也叫散列表），通过把关键码值映射到Hash表中一个位置来访问记录，查找时间复杂度可达O（1），其中在海量数据处理中有着广泛应用。因此，元素的排列顺序是无序的。</li></ol><h3 id="46-说说-vector-和-list-的区别，分别适用于什么场景？"><a href="#46-说说-vector-和-list-的区别，分别适用于什么场景？" class="headerlink" title="46.说说 vector 和 list 的区别，分别适用于什么场景？"></a>46.说说 vector 和 list 的区别，分别适用于什么场景？</h3><p>vector和list区别在于底层实现机理不同，因而特性和适用场景也有所不同。</p><ol><li>vector：一维数组<ul><li>特点：元素在内存连续存放，动态数组，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后内存也不会释放。</li><li>优点：和数组类似开辟一段连续的空间，并且支持随机访问，所以它的查找效率高其时间复杂度O(1)。</li><li>缺点：由于开辟一段连续的空间，所以插入删除会需要对数据进行移动比较麻烦，时间复杂度O（n），另外当空间不足时还需要进行扩容。</li></ul></li><li>list：双向链表<ul><li>特点：元素在堆中存放，每个元素都是存放在一块内存中，它的内存空间可以是不连续的，通过指针来进行数据的访问。</li><li>优点：底层实现是循环双链表，当对大量数据进行插入删除时，其时间复杂度O(1)。</li><li>缺点：底层没有连续的空间，只能通过指针来访问，所以查找数据需要遍历其时间复杂度O（n），没有提供[]操作符的重载。<br>应用场景</li><li>vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。</li><li>list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。</li></ul></li></ol><h3 id="47-map-和-set-有什么区别，分别又是怎么实现的？"><a href="#47-map-和-set-有什么区别，分别又是怎么实现的？" class="headerlink" title="47. map 和 set 有什么区别，分别又是怎么实现的？"></a>47. map 和 set 有什么区别，分别又是怎么实现的？</h3><ol><li>set是一种关联式容器，其特性如下：<br>（1）set以RBTree作为底层容器<br>（2）所得元素的只有key没有value，value就是key<br>（3）不允许出现键值重复<br>（4）所有的元素都会被自动排序<br>（5）不能通过迭代器来改变set的值，因为set的值就是键，set的迭代器是const的</li><li>map和set一样是关联式容器，其特性如下：<br>（1）map以RBTree作为底层容器<br>（2）所有元素都是键+值存在<br>（3）不允许键重复<br>（4）所有元素是通过键进行自动排序的<br>（5）map的键是不能修改的，但是其键对应的值是可以修改的<br>综上所述，map和set底层实现都是红黑树；map和set的区别在于map的值不作为键，键和值是分开的。</li></ol><h3 id="48-push-back-和-emplace-back-的区别"><a href="#48-push-back-和-emplace-back-的区别" class="headerlink" title="48. push_back 和 emplace_back 的区别"></a>48. push_back 和 emplace_back 的区别</h3><p>如果要将一个临时变量push到容器的末尾，push_back()需要先构造临时对象，再将这个对象拷贝到容器的末尾，而emplace_back()则直接在容器的末尾构造对象，这样就省去了拷贝的过程。</p><h3 id="49-vector扩容"><a href="#49-vector扩容" class="headerlink" title="49. vector扩容"></a>49. vector扩容</h3><p>Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，再插入新增的元素。<br>vector的扩容一般有两种方式：半步扩容法（即扩容1.5倍）和2倍扩容法（即扩容2倍）<br>两者之间的区别重点表现在空间和时间两方面。<br>2倍扩容时间快，但是不能使用之前的空间，造成空间上的浪费。而1.5倍扩容刚好相反，节省了空间，却因此消耗了更多的时间。</p><table><thead><tr><th align="center">编译器</th><th align="center">扩容倍数</th></tr></thead><tbody><tr><td align="center">GCC</td><td align="center">2</td></tr><tr><td align="center">MSVC</td><td align="center">1.5</td></tr><tr><td align="center">CLANG</td><td align="center">1.5</td></tr></tbody></table><h3 id="50-C-11-的新特性有哪些"><a href="#50-C-11-的新特性有哪些" class="headerlink" title="50.  C++11 的新特性有哪些"></a>50.  C++11 的新特性有哪些</h3><p>C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点：</p><ol><li>语法的改进<br>（1）统一的初始化方法<br>（2）成员变量默认初始化<br>（3）auto关键字    用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）<br>（4）decltype    求表达式的类型<br>（5）智能指针 shared_ptr<br>（6）空指针 nullptr（原来NULL）<br>（7）基于范围的for循环<br>（8）右值引用和move语义    让程序员有意识减少进行深拷贝操作</li><li>标准库扩充（往STL里新加进一些模板类，比较好用）<br>（9）无序容器（哈希表）    用法和功能同map一模一样，区别在于哈希表的效率更高<br>（10）正则表达式    可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串<br>（11）Lambda表达式</li></ol><hr><p><strong>decltype    求表达式的类型</strong><br>decltype 是 C++11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。<br>(1)为什么要有decltype<br>    因为 auto 并不适用于所有的自动类型推导场景，在某些特殊情况下 auto 用起来非常不方便，甚至压根无法使用，所以 decltype 关键字也被引入到 C++11 中。<br>    auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：<br>    <code>auto varname = value; decltype(exp) varname = value;</code><br>    其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。<br>    auto 根据”&#x3D;”右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟”&#x3D;”右边的 value 没有关系。<br>    另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。decltype 可以写成下面的形式：<br>    <code>decltype(exp) varname;</code><br>(2)代码示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// decltype 用法举例 </span><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; <span class="hljs-keyword">decltype</span>(a) b = <span class="hljs-number">1</span>;  <span class="hljs-comment">//b 被推导成了int </span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-number">10.8</span>) x = <span class="hljs-number">5.5</span>;  <span class="hljs-comment">//x 被推导成了 double </span><br><span class="hljs-keyword">decltype</span>(x + <span class="hljs-number">100</span>) y;  <span class="hljs-comment">//y 被推导成了 double</span><br></code></pre></td></tr></table></figure><p><strong>智能指针 shared_ptr</strong><br>    和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">//构建 2 个智能指针</span><br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<br>    <span class="hljs-comment">//输出 p2 指向的数据</span><br>    cout &lt;&lt; *p2 &lt;&lt; endl;<br>    p1.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">//引用计数减 1,p1为空指针</span><br>    <span class="hljs-keyword">if</span> (p1)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;p1 不为空&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;p1 为空&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//以上操作，并不会影响 p2</span><br>    cout &lt;&lt; *p2 &lt;&lt; endl;<br>    <span class="hljs-comment">//判断当前和 p2 同指向的智能指针有多少个</span><br>    cout &lt;&lt; p2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*      程序运行结果：          10  p1 为空  10  1  */</span><br></code></pre></td></tr></table></figure><p><strong>正则表达式</strong><br>可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串。常用符号的意义如下：</p><table><thead><tr><th align="center">符号</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">^</td><td align="center">匹配行的开头</td></tr><tr><td align="center">$</td><td align="center">匹配行的结尾</td></tr><tr><td align="center">.</td><td align="center">匹配任意单个字符</td></tr><tr><td align="center">[…]</td><td align="center">匹配[]中的任意一个字符</td></tr><tr><td align="center">(…)</td><td align="center">设定分组</td></tr><tr><td align="center">\</td><td align="center">转义字符</td></tr><tr><td align="center">\d</td><td align="center">匹配数字[0-9]</td></tr><tr><td align="center">\D</td><td align="center">\d 取反</td></tr><tr><td align="center">\w</td><td align="center">匹配字母[a-z]，数字，下划线</td></tr><tr><td align="center">\W</td><td align="center">\w 取反</td></tr><tr><td align="center">\s</td><td align="center">匹配空格</td></tr><tr><td align="center">\S</td><td align="center">\s 取反</td></tr><tr><td align="center">+</td><td align="center">前面的元素重复1次或多次</td></tr><tr><td align="center">*</td><td align="center">前面的元素重复任意次</td></tr><tr><td align="center">?</td><td align="center">前面的元素重复0次或1次</td></tr><tr><td align="center">{n}</td><td align="center">前面的元素重复n次</td></tr><tr><td align="center">{n,}</td><td align="center">前面的元素重复至少n次</td></tr><tr><td align="center">{n,m}</td><td align="center">前面的元素重复至少n次，至多m次</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><p><strong>Lambda匿名函数</strong><br>所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。<br>（1）定义<br>    lambda 匿名函数很简单，可以套用如下的语法格式：<br>      <code>[外部变量访问方式说明符] (参数) mutable noexcept/throw() -&gt; 返回值类型         &#123;           函数体;         &#125;;</code><br>其中各部分的含义分别为：<br>a. [外部变量方位方式说明符]     [ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。<br>    所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。<br>b. (参数)     和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；<br>c. mutable     此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。<br>    注意:对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；<br>d. noexcept&#x2F;throw()     可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。<br>e. -&gt; 返回值类型     指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略”-&gt; 返回值类型”。<br>f. 函数体     和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。<br>（2）程序实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> num[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-comment">//对 a 数组中的元素进行排序</span><br>    <span class="hljs-built_in">sort</span>(num, num+<span class="hljs-number">4</span>, [=](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">bool</span>&#123; <span class="hljs-keyword">return</span> x &lt; y; &#125; );<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : num)&#123;<br>        cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*    程序运行结果：</span><br><span class="hljs-comment">          1 2 3 4</span><br><span class="hljs-comment">*/</span>  <br></code></pre></td></tr></table></figure><h3 id="51-C-中智能指针和指针的区别是什么？"><a href="#51-C-中智能指针和指针的区别是什么？" class="headerlink" title="51. C++ 中智能指针和指针的区别是什么？"></a>51. C++ 中智能指针和指针的区别是什么？</h3><ol><li>智能指针<br> 如果在程序中使用new从堆（自由存储区）分配内存，等到不需要时，应使用delete将其释放。C++引用了智能指针auto_ptr，以帮助自动完成这个过程。随后的编程体验（尤其是使用STL）表明，需要有更精致的机制。基于程序员的编程体验和BOOST库提供的解决方案，C++11摒弃了auto_ptr，并新增了三种智能指针：unique_ptr、shared_ptr和weak_ptr。所有新增的智能指针都能与STL容器和移动语义协同工作。</li><li>指针<br> C 语言规定所有变量在使用前必须先定义，指定其类型，并按此分配内存单元。指针变量不同于整型变量和其他类型的变量，它是专门用来存放地址的，所以必须将它定义为“指针类型”。</li><li>智能指针和普通指针的区别<br> 智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。</li></ol><h3 id="52-C-中的智能指针有哪些？分别解决的问题以及区别？"><a href="#52-C-中的智能指针有哪些？分别解决的问题以及区别？" class="headerlink" title="52. C++中的智能指针有哪些？分别解决的问题以及区别？"></a>52. C++中的智能指针有哪些？分别解决的问题以及区别？</h3><p>C++中的智能指针有4种，分别为：shared_ptr、unique_ptr、weak_ptr、auto_ptr，其中auto_ptr被C++11弃用。</p><ol><li><p>使用智能指针的原因<br> 申请的空间（即new出来的空间），在使用结束时，需要delete掉，否则会形成内存碎片。在程序运行期间，new出来的对象，在析构函数中delete掉，但是这种方法不能解决所有问题，因为有时候new发生在某个全局函数里面，该方法会给程序员造成精神负担。此时，智能指针就派上了用场。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以，智能指针的作用原理就是在函数结束时自动释放内存空间，避免了手动释放内存空间。</p></li><li><p>四种指针分别解决的问题以及各自特性如下：</p><ol><li>auto_ptr（C++98的方案，C++11已经弃用）<br> 采用所有权模式。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I reigned loney as a cloud.&quot;</span>))</span></span>;<br>auto_ptr&lt;string&gt; p2;<br>p2=p1; <span class="hljs-comment">//auto_ptr不会报错</span><br></code></pre></td></tr></table></figure>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题。</li><li>unique_ptr（替换auto_ptr）<br>unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露，例如，以new创建对象后因为发生异常而忘记调用delete时的情形特别有用。<br>采用所有权模式，和上面例子一样。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I reigned loney as a cloud.&quot;</span>))</span></span>;<br>auto_ptr&lt;string&gt; p4;<br>p4=p3; <span class="hljs-comment">//此时不会报错</span><br></code></pre></td></tr></table></figure><p>编译器认为P4&#x3D;P3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。 另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">pu1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string (<span class="hljs-string">&quot;hello world&quot;</span>))</span></span>;<br>unique_ptr&lt;string&gt; pu2;<br>pu2 = pu1;                                      <span class="hljs-comment">// #1 not allowed</span><br>unique_ptr&lt;string&gt; pu3;<br>pu3 = <span class="hljs-built_in">unique_ptr</span>&lt;string&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span> (<span class="hljs-string">&quot;You&quot;</span>));   <span class="hljs-comment">// #2 allowed</span><br></code></pre></td></tr></table></figure><p>其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</p><p>注意：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unique_ptr&lt;string&gt; ps1, ps2;<br>ps1 = <span class="hljs-built_in">demo</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>ps2 = <span class="hljs-built_in">move</span>(ps1);<br>ps1 = <span class="hljs-built_in">demo</span>(<span class="hljs-string">&quot;alexia&quot;</span>);<br>cout &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; endl;<br></code></pre></td></tr></table></figure><ol start="3"><li>shared_ptr（非常好使）<br> shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。<br> shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。<ul><li>成员函数：<ul><li>use_count    返回引用计数的个数</li><li>unique    返回是否是独占所有权( use_count 为 1)</li><li>swap    交换两个 shared_ptr 对象(即交换所拥有的对象)</li><li>reset    放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</li><li>get    返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的</li></ul></li></ul></li><li>weak_ptr<br> weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr。weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>   shared_ptr&lt;B&gt; pb_;<br>   ~<span class="hljs-built_in">A</span>()<br>&#123;<br>   cout&lt;&lt;<span class="hljs-string">&quot;A delete\n&quot;</span>;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>   shared_ptr&lt;A&gt; pa_;<br>   ~<span class="hljs-built_in">B</span>()<br>&#123;<br>   cout&lt;&lt;<span class="hljs-string">&quot;B delete\n&quot;</span>;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-function">shared_ptr&lt;B&gt; <span class="hljs-title">pb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;<br>   <span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">pa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>   pb-&gt;pa_ = pa;<br>   pa-&gt;pb_ = pb;<br>   cout&lt;&lt;pb.<span class="hljs-built_in">use_count</span>()&lt;&lt;endl;<br>   cout&lt;&lt;pa.<span class="hljs-built_in">use_count</span>()&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-built_in">fun</span>();<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。</p><p>注意：我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa-&gt;pb-&gt;print(); 英文pb是一个weak_ptr，应该先把它转化为shared_ptr，如：shared_ptr p &#x3D; pa-&gt;pb_.lock(); p-&gt;print();</p></li></ol><h3 id="53-简述-C-中智能指针的特点"><a href="#53-简述-C-中智能指针的特点" class="headerlink" title="53. 简述 C++ 中智能指针的特点"></a>53. 简述 C++ 中智能指针的特点</h3><p>C++中的智能指针有4种，分别为：shared_ptr、unique_ptr、weak_ptr、auto_ptr，其中auto_ptr被C++11弃用。    </p><ol><li>为什么要使用智能指针：智能指针的作用是管理一个指针，因为存在申请的空间在函数结束时忘记释放，造成内存泄漏的情况。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，自动释放资源。</li><li>四种指针各自特性<br>（1）auto_ptr<br>   auto指针存在的问题是，两个智能指针同时指向一块内存，就会两次释放同一块资源，自然报错。<br>（2）unique_ptr<br>   unique指针规定一个智能指针独占一块内存资源。当两个智能指针同时指向一块内存，编译报错。<br>   实现原理：将拷贝构造函数和赋值拷贝构造函数申明为private或delete。不允许拷贝构造函数和赋值操作符，但是支持移动构造函数，通过std:move把一个对象指针变成右值之后可以移动给另一个unique_ptr<br>（3）shared_ptr<br>   共享指针可以实现多个智能指针指向相同对象，该对象和其相关资源会在引用为0时被销毁释放。<br>   实现原理：有一个引用计数的指针类型变量，专门用于引用计数，使用拷贝构造函数和赋值拷贝构造函数时，引用计数加1，当引用计数为0时，释放资源。<br>注意：weak_ptr、shared_ptr存在一个问题，当两个shared_ptr指针相互引用时，那么这两个指针的引用计数不会下降为0，资源得不到释放。因此引入weak_ptr，weak_ptr是弱引用，weak_ptr的构造和析构不会引起引用计数的增加或减少。</li></ol><h3 id="54-weak-ptr-能不能知道对象计数为-0，为什么？"><a href="#54-weak-ptr-能不能知道对象计数为-0，为什么？" class="headerlink" title="54. weak_ptr 能不能知道对象计数为 0，为什么？"></a>54. weak_ptr 能不能知道对象计数为 0，为什么？</h3><p>不能。<br>weak_ptr是一种不控制对象生命周期的智能指针，它指向一个shared_ptr管理的对象。进行该对象管理的是那个引用的shared_ptr。weak_ptr只是提供了对管理 对象的一个访问手段。weak_ptr设计的目的只是为了配合shared_ptr而引入的一种智能指针，配合shared_ptr工作，它只可以从一个shared_ptr或者另一个weak_ptr对象构造，它的构造和析构不会引起计数的增加或减少。</p><h3 id="55-weak-ptr-如何解决-shared-ptr-的循环引用问题？"><a href="#55-weak-ptr-如何解决-shared-ptr-的循环引用问题？" class="headerlink" title="55. weak_ptr 如何解决 shared_ptr 的循环引用问题？"></a>55. weak_ptr 如何解决 shared_ptr 的循环引用问题？</h3><p>为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p><h3 id="56-share-ptr-怎么知道跟它共享对象的指针释放了"><a href="#56-share-ptr-怎么知道跟它共享对象的指针释放了" class="headerlink" title="56. share_ptr 怎么知道跟它共享对象的指针释放了"></a>56. share_ptr 怎么知道跟它共享对象的指针释放了</h3><p>多个shared_ptr对象可以同时托管一个指针，系统会维护一个托管计数。当无shared_ptr托管该指针时，delete该指针。</p><h3 id="57-智能指针有没有内存泄露的情况"><a href="#57-智能指针有没有内存泄露的情况" class="headerlink" title="57. 智能指针有没有内存泄露的情况"></a>57. 智能指针有没有内存泄露的情况</h3><p>智能指针有内存泄露的情况发生。</p><ol><li>智能指针发生内存泄露的情况<br>当两个对象同时使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄露。</li><li>智能指针的内存泄漏如何解决？<br>为了解决循环引用导致的内存泄漏，引入了弱指针weak_ptr，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问。</li></ol><h3 id="58-简述一下-C-11-中四种类型转换"><a href="#58-简述一下-C-11-中四种类型转换" class="headerlink" title="58. 简述一下 C++11 中四种类型转换"></a>58. 简述一下 C++11 中四种类型转换</h3><p>C++中四种类型转换分别为const_cast、static_cast、dynamic_cast、reinterpret_cast，四种转换功能分别如下：</p><ol><li><p>const_cast<br> 将const变量转为非const</p></li><li><p>static_cast<br> 最常用，可以用于各种隐式转换，比如非const转const，static_cast可以用于类向上转换，但向下转换能成功但是不安全。</p></li><li><p>dynamic_cast<br>只能用于含有虚函数的类转换，用于类向上和向下转换</p><ul><li>向上转换：指子类向基类转换。    </li><li>向下转换：指基类向子类转换。</li></ul><p>这两种转换，子类包含父类，当父类转换成子类时可能出现非法内存访问的问题。<br>dynamic_cast通过判断变量运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。dynamic_cast可以做类之间上下转换，转换的时候会进行类型检查，类型相等成功转换，类型不等转换失败。运用RTTI技术，RTTI是”Runtime Type Information”的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法。在c++层面主要体现在dynamic_cast和typeid，vs中虚函数表的-1位置存放了指向type_info的指针，对于存在虚函数的类型，dynamic_cast和typeid都会去查询type_info。</p></li><li><p>reinterpret_cast<br>     reinterpret_cast可以做任何类型的转换，不过不对转换结果保证，容易出问题。<br>注意：为什么不用C的强制转换：C的强制转换表面上看起来功能强大什么都能转，但是转换不够明确，不能进行错误检查，容易出错。</p></li></ol><h3 id="59-auto和-const-的结合使用"><a href="#59-auto和-const-的结合使用" class="headerlink" title="59. auto和 const 的结合使用"></a>59. auto和 const 的结合使用</h3><ol><li>auto 与 const 结合的用法<br> a. 当类型不为引用时，auto 的推导结果将不保留表达式的 const 属性；<br> b. 当类型为引用时，auto 的推导结果将保留表达式的 const 属性。</li><li>程序实例如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>  x = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span>  <span class="hljs-keyword">auto</span> n = x;  <span class="hljs-comment">//n 为 const int ，auto 被推导为 int</span><br><span class="hljs-keyword">auto</span> f = n;      <span class="hljs-comment">//f 为 const int，auto 被推导为 int（const 属性被抛弃）</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;r1 = x;  <span class="hljs-comment">//r1 为 const int&amp; 类型，auto 被推导为 int</span><br><span class="hljs-keyword">auto</span> &amp;r2 = r1;  <span class="hljs-comment">//r1 为 const int&amp; 类型，auto 被推导为 const int 类型</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">a. 第 2 行代码中，n 为 const int，auto 被推导为 int。</span><br><span class="hljs-comment">b. 第 3 行代码中，n 为 const int 类型，但是 auto 却被推导为 int 类型，这说明当=右边的表达式带有 const 属性时，auto 不会    使用 const 属性，而是直接推导出 non-const 类型。</span><br><span class="hljs-comment">c. 第 4 行代码中，auto 被推导为 int 类型，这个很容易理解，不再赘述。</span><br><span class="hljs-comment">d. 第 5 行代码中，r1 是 const int &amp; 类型，auto 也被推导为 const int 类型，这说明当 const 和引用结合时，auto 的推导将保留    表达式的 const 类型。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="60-可变参数模板"><a href="#60-可变参数模板" class="headerlink" title="60. 可变参数模板"></a>60. 可变参数模板</h3><ol><li><p>C++11的新特性可变参数模板能够让您创建可以接受可变参数的函数模板和类模板，相比C++98&#x2F;03，类模版和函数模版中只能含固定数量的模版参数，可变模版参数无疑是一个巨大的改进。然而由于可变模版参数比较抽象，使用起来需要一定的技巧，所以这块还是比较晦涩的。现阶段呢，我们掌握一些基础的可变参数模板特性就够我们用了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Args是一个模板参数包，args是一个函数形参参数包</span><br><span class="hljs-comment">// 声明一个参数包Args...args，这个参数包中可以包含0到任意个模板参数。</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> ...Args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowList</span><span class="hljs-params">(Args... args)</span></span><br><span class="hljs-function"></span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>上面的参数args前面有省略号，所以它就是一个可变模版参数，我们把带省略号的参数称为“参数包”，它里面包含了0到N（N&gt;&#x3D;0）个模版参数。我们无法直接获取参数包args中的每个参数的，只能通过展开参数包的方式来获取参数包中的每个参数，这是使用可变模版参数的一个主要特点，也是最大的难点，即如何展开可变模版参数。由于语法不支持使用args[i]这样方式获取可变参数，所以我们的用一些奇招来一一获取参数包的值。</p></li><li><p>递归函数方式展开参数包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 递归终止函数，当只有一个参数时特殊处理</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T, <span class="hljs-keyword">class</span> ...Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowList</span><span class="hljs-params">(T value)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(value).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T, <span class="hljs-keyword">class</span> ...Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowList</span><span class="hljs-params">(T value, Args... args)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// cout &lt;&lt; sizoef(args...) &lt;&lt; endl;无法计算可变参数的大小</span><br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(value).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; endl;<br><span class="hljs-built_in">ShowList</span>(args...); <span class="hljs-comment">// 他会自动解析出一个类型给 value </span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">ShowList</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">ShowList</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-built_in">ShowList</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;A&#x27;</span>, std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;sort&quot;</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>逗号表达式展开参数包<br>这种展开参数包的方式，不需要通过递归终止函数，是直接在expand函数体中展开的, printarg不是一个递归终止函数，只是一个处理参数包中每一个参数的函数。<br>这种就地展开参数包的方式实现的关键是逗号表达式。我们知道逗号表达式会按顺序执行逗号前面的表达式。<br>expand函数中的逗号表达式：(printarg(args), 0)，也是按照这个执行顺序，先执行printarg(args)，再得到逗号表达式的结果0。同时还用到了C++11的另外一个特性——初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)…}将会展开成((printarg(arg1),0),<br>(printarg(arg2),0), (printarg(arg3),0), etc… )，最终会创建一个元素值都为0的数组int arr[sizeof…(Args)]。<br>由于是逗号表达式，在创建数组的过程中会先执行逗号表达式前面的部分printarg(args)打印出参数，也就是说在构造int数组的过程中就将参数包展开了，这个数组的目的纯粹是为了在数组构造的过程展开参数包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printarg</span><span class="hljs-params">(T value)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(value).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> ...Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowList</span><span class="hljs-params">(Args... args)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> arr[] = &#123; (<span class="hljs-built_in">printarg</span>(args), <span class="hljs-number">0</span>)... &#125;;<br><span class="hljs-comment">// 编译器需要计算数组的大小，后面调用函数，每次传递一个参数。由逗号表达式，最后数组值都是0</span><br><span class="hljs-comment">// 三个点表示安装前面括号里面的方式依次展开</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i ++ )<br>&#123;<br>cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//ShowList(1);</span><br><span class="hljs-comment">//ShowList(1, &#x27;A&#x27;);</span><br><span class="hljs-built_in">ShowList</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;A&#x27;</span>, std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;sort&quot;</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="61-lambda表达式"><a href="#61-lambda表达式" class="headerlink" title="61. lambda表达式"></a>61. lambda表达式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[capture] (params) opt -&gt; ret &#123;&#125;;<br></code></pre></td></tr></table></figure><p>其中carpture是捕获列表，params是参数，opt是选项，ret则是返回值的类型，body则是函数的具体实现。</p><ol><li>捕获列表描述了lambda表达式可以访问上下文中的哪些变量： []：表示不捕获任何变量。 [&#x3D;]：表示按值捕获变量，也就是说在lambda函数内使用lambda之外的变量时，使用的是拷贝。 [&amp;]：表示按引用捕获变量，也就是说在lambda函数内使用lambda之外的变量时，使用的是引用。 [this]：值传递捕获当前的this。</li><li>params表示lambda的参数，用在{}中。</li><li>opt表示lambda的选项，例如mutable。</li><li>ret表示lambda的返回类型，也可以显示指明返回类型，lambda会自动推断返回类型，但是值得注意的是只有当lambda的表达式仅有一条return语句时，自动推断才是有效的。</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20220921_中移苏州面试总结</title>
    <link href="/2022/09/22/ch20220921/"/>
    <url>/2022/09/22/ch20220921/</url>
    
    <content type="html"><![CDATA[<p>20220921中国移动苏州云能力中心面试总结</p><h3 id="1-TCP-x2F-IP三次握手"><a href="#1-TCP-x2F-IP三次握手" class="headerlink" title="1. TCP&#x2F;IP三次握手"></a>1. TCP&#x2F;IP三次握手</h3><pre><code class="hljs">第一次握手：客户端向服务器端发起请求，发送SYN包和seq=x;第二次握手：服务器端受到客户端的SYN包，响应回复一个ACK=x+1包确认收到，同时发送自己的SYN(seq=y);第三次握手：客户端受到服务器的ACK和SYN，响应回复一个ACK=y+1向客户端确认收到完成三次握手，连接建立开始通信</code></pre><h3 id="2-C-四种强制类型转换"><a href="#2-C-四种强制类型转换" class="headerlink" title="2. C++四种强制类型转换"></a>2. C++四种强制类型转换</h3><ol><li>static_cast: <code>static_cast&lt;type_id-&gt;类型说明符&gt;(expression-&gt;变量或表达式)</code><br>用于数据类型的强制转换，强制将一种数据类型转换为另一种数据类型；<br>主要用法：<ol><li>用于类层次结构中积累和派生类之间指针或引用的转换；<ol><li>进行上行转换（把派生类的指针或引用转换为基类表示）是安全的；</li><li>进行下行转换（把基类的指针或引用转换为派生类表示）由于没有动态类型检查，是不安全的；</li></ol></li><li>用于基本数据类型之间的转换，如int转换成char，这种转换也需要开发人员来保证；</li><li>把空指针转换成目标类型的空指针；</li><li>把任何类型的表达式转换为void类型；<br>注意:<br>  static_cast不能转换掉表达式中的const、volitale或者——unaligend属性<br>  如果涉及到类，只能在有相互联系的类型中精选相互转换，不一定包含虚函数</li></ol></li><li>const_cast: <code>const_cast&lt;type_id&gt;(expression)</code><ol><li>const_cast用于强制去掉const这种不能被修改的常数特性，但是，const_cast不是用于去除变量的常量属性，而是去除指向常量对象的指针或引用的常量属性，其去除的对象必须是指针或引用;</li><li>可以用来修改类型的const和volatile属性，出来const或volatile修饰之外，type_id和expression的类型是一样的；</li><li>用法：<ul><li>常量指针被转化成非常量指针，并且仍然指向原来的对象；</li><li>常量引用被转换成非常量引用，并且仍然指向原来的对象；</li><li>常量对象被转换成非常量对象。</li></ul></li><li>不建议使用const_cast去掉指针或引用的常量属性从而修改原始变量的数值；</li></ol></li><li>reinterpret_cast: <code>reinterpret_cast&lt;type_id&gt;(expression)</code><ol><li>在C++语言中，reinterpret_cast主要有三种强制转换用途：<ul><li>改变指针或引用的类型;</li><li>将指针或引用转换为一个足够长度的整型;</li><li>将整型转换为指针或引用类型。</li></ul></li><li>type-id必须是一个指针、引用、算术类型、函数指针或者成员指针</li></ol></li><li>dynamic_cast: <code>dynamic_cast&lt;typr_id&gt;(expression)</code><ol><li>其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。</li><li>不能用于内置的基本数据类型的强制转换。</li><li>dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。</li><li>使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过。<ul><li>需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。</li><li>这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表, 只有定义了虚函数的类才有虚函数表。</li></ul></li><li>在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全<ul><li>向上转换，即为子类指针指向父类指针（一般不会出问题）；向下转换，即将父类指针转化子类指针。<br>  向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。<br>  在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。Dynamic_cast操作符则可以在运行期对可能产生问题的类型转换进行测试。</li></ul></li></ol></li></ol><h3 id="3-C-四种智能指针"><a href="#3-C-四种智能指针" class="headerlink" title="3. C++四种智能指针"></a>3. C++四种智能指针</h3><ol><li>为什么需要智能指针？<br>如果指针使用完忘记delete，将会造成内存泄漏，而使用智能指针时，当超出了智能指针类的作用域时，智能指针会自动调用析构函数，自动释放资源</li><li>内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果;</li><li>auto_ptr:<ol><li>采用独占式拥有模式，已被C++11弃用;  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;hello&quot;</span>))</span></span>;<br>auto_ptr&lt;string&gt; p2;<br>p2 = p1;    <span class="hljs-comment">// 可以通过</span><br><span class="hljs-comment">// cout&lt;&lt;*p2&lt;&lt;endl;</span><br><span class="hljs-comment">// cout&lt;&lt;*p1&lt;&lt;endl;     // 当程序运行时访问p1将会报错，因为所有权从p1转让给了p2，此时p1不再拥有该字符串对象从而变成空指针</span><br></code></pre></td></tr></table></figure></li></ol></li><li>unique_ptr:<br>unique_ptr用于替换auto_ptr，实现了独占式拥有的概念，同时保证同一时间内只有一个智能指针可以指向该对象，因此，unique_ptr的拷贝构造函数和拷贝赋值构造函数均被声明为delete，无法实现拷贝和赋值操作，但可以通过移动构造和移动赋值操作，对于避免内存泄漏十分有效； <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;hello&quot;</span>))</span></span>;<br>unique_ptr&lt;string&gt; p2;<br>p2 = p1;    <span class="hljs-comment">// 此时无法通过编译</span><br><span class="hljs-comment">// cout&lt;&lt;*p2&lt;&lt;endl;</span><br><span class="hljs-comment">// cout&lt;&lt;*p1&lt;&lt;endl;</span><br></code></pre></td></tr></table></figure></li><li>shared_ptr:<ol><li>shared_ptr实现共享式拥有的概念，通过引用计数，多个智能指针可以   指向相同的对象，该对象和其相关资源会在最后一个引用被销毁，即引用计数&#x3D;0的时候释放。 </li><li>它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。</li><li>当复制一个shared_ptr，引用计数会+1。当我们调用release()或者当一个shared_ptr离开作用域时，计数减1（普通的指针如果没有delete操作，离开作用域时并不会被释放，只有在进程结束后才会被释放）。当计数等于0时，则delete内存。</li><li>share_ptr的缺点为：当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏，此时需要使用weak_ptr；</li><li>shared_ptr的安全性：<ul><li>引用计数增加是安全的，引用计数在堆上；</li><li>不同线程同时操作一个shared_ptr的引用的不安全的；</li><li>不同的shared_ptr指向同一块内存，操作同一个内存也是不安全的，即shared_ptr指向对象的读写并不是线程安全的；</li></ul></li><li>智能指针shared_ptr的两种初始化方式:  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;   <span class="hljs-comment">//通过new构造数据对象，调用了shared_ptr的构造函数</span><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp2 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>); <span class="hljs-comment">//通过make_shared构造数据对象；</span><br></code></pre></td></tr></table></figure><ol><li>通过new构造，涉及到两次内存分配，第一次是通过new为数据对象分配内存，即上方的new int(10)，第二次是构造一个shared_ptr的管理对象，管理对象记录了强引用(shared_ptr)计数，弱引用(weak_ptr)计数，以及数据对象（new int(10)）的地址。当管理对象发现强引用计数为0时，释放数据对象的内存，当管理对象发现弱引用计数为0时，释放管理对象的内存;</li><li>通过make_shared构造，只分配一次内存，这一块内存里既包括管理对象，也包括数据对象。由于是在一块内存里，所以即使强引用计数已被清零，但如果弱引用计数还没有清零，那么也无法释放这一块内存，直到弱引用计数清零时，这一块内存（包括管理对象和数据对象）才能被释放。</li><li>构造函数是保护或私有时,无法使用 make_shared();</li><li>share_ptr销毁了，但还有weak_ptr指向那个对象，weak_ptr怎么知道这个对象已销毁？<ul><li>share_ptr销毁的时候，只是把指向的对象销毁了，而计数器Counter还没被销毁，Counter里面记录了share_ptr的引用计数以及weak_ptr的引用计数，weak_ptr可以通过查询Counter里面的值来知道对象已被销毁。当weak_ptr也小于1时，Counter才会被销毁。</li></ul></li></ol></li></ol></li><li>weak_ptr:<ol><li>weak_ptr是用来解决shared_ptr相互引用时的死锁问题，如果两个shared_ptr相互引用，那么两个指针的引用计数将永远不可能下降为0，资源将永远得不到释放；</li><li>weak_ptr是对对象的一种弱引用，不会增加对象的引用计数；</li><li>weak_ptr可以和shared_ptr之间相互转化，shared_ptr可以直接赋值给weak_ptr, 而weak_ptr可以通过lock()函数来获得shared_ptr;</li><li>不能直接通过weak_ptr访问对象的方法，需要使用lock()函数转化成shared_ptr对象后再访问，weak_ptr没有重载<code>*</code>和<code>-&gt;</code>运算符。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<span class="hljs-comment">//声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    shared_ptr&lt;B&gt; pb_;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;class A&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    ~<span class="hljs-built_in">A</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A delete\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// shared_ptr&lt;A&gt; pa_;</span><br>    weak_ptr&lt;A&gt; pa_;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;class B&quot;</span>&lt;&lt;endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">B</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;B delete\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;B&gt; <span class="hljs-title">pb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;<br>    <span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">pa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>    cout &lt;&lt; pb.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<span class="hljs-comment">//1</span><br>    cout &lt;&lt; pa.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<span class="hljs-comment">//1</span><br>    pb-&gt;pa_ = pa;<br>    pa-&gt;pb_ = pb;<br>    cout &lt;&lt; pb.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<span class="hljs-comment">//2</span><br>    cout &lt;&lt; pa.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<span class="hljs-comment">//2</span><br><br>    <span class="hljs-comment">// pb-&gt;pa_-&gt;print();    // 报错</span><br>    pb-&gt;pa_.<span class="hljs-built_in">lock</span>()-&gt;<span class="hljs-built_in">print</span>();<br>    pa-&gt;pb_-&gt;<span class="hljs-built_in">print</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fun</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="5-深拷贝和浅拷贝"><a href="#5-深拷贝和浅拷贝" class="headerlink" title="5. 深拷贝和浅拷贝"></a>5. 深拷贝和浅拷贝</h3><ol><li>浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的；</li><li>深拷贝：拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。</li><li>在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。</li><li>深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。</li></ol><h3 id="6-vector如何自动扩容"><a href="#6-vector如何自动扩容" class="headerlink" title="6. vector如何自动扩容"></a>6. vector如何自动扩容</h3><ol><li>整体的一个扩容流程为：申请新的内存空间（空间大小为原空间的两倍或一点五倍）—&gt; 把原空间的元素拷贝到新的空间里 —&gt; 释放原空间 —&gt; 数组指针指向新空间。</li><li>不同的的编译器实现方式不同,vs编译器每次是以1.5倍且向下取整的策略进行扩容，gcc编译器则是每次以2.0倍的策略进行扩容。</li><li>扩充的过程并不是直接在原有空间后⾯追加容量，⽽是重新申请⼀块连续空间，将原有的数据拷⻉到新空间中，再释放原有空间，完成⼀次扩充。 需要注意的是，每次扩充是重新开辟的空间，所以扩充后，原有的迭代器将会失效;</li></ol><h3 id="7-进程间通信的方式"><a href="#7-进程间通信的方式" class="headerlink" title="7. 进程间通信的方式"></a>7. 进程间通信的方式</h3><ol><li>管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li><li>命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li><li>消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>共享内存SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li><li>信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li>套接字Socket：套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机及其间的进程通信。</li><li>信号 ( singal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li></ol>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>面试</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello Wolrd</title>
    <link href="/2021/06/22/Hello-Wolrd/"/>
    <url>/2021/06/22/Hello-Wolrd/</url>
    
    <content type="html"><![CDATA[<h3 id="你好，欢迎来到我的博客"><a href="#你好，欢迎来到我的博客" class="headerlink" title="你好，欢迎来到我的博客"></a>你好，欢迎来到我的博客</h3><p>在这里将会发布一些个人的技术感想和思考，谢谢关注</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
